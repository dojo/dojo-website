<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The Dojo Loader &mdash; The Dojo Toolkit - Reference Guide</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.10.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>

    <link rel="stylesheet" href="../../../../css/guide.css">
    <script type="text/javascript">
      dojoConfig = {
        async: true
      };
    </script>
    <script src="../../../scripts/dojo/dojo/dojo.js"></script>
    <script src="../../../../scripts/guide/docs/guide.js"></script>
    <link rel="stylesheet" href="../../../../scripts/dojo/dijit/themes/claro/claro.css">

  </head>
  <body role="document">
  

    <div class="document">

  <div class="nav">
	<div class="row">
		<div class="small-3 columns">
			<a href="/" class="navLogo"><span>Dojo</span></a>
		</div>
		<div class="small-9 columns text-right">
			<div class="mobileMenuToggle" data-menu-toggle></div>
			<div class="menu">
				<div class="mobileHeader">Menu</div>
				<ul class="inline-list menuItems right">
					<li><a href="">Get Dojo</a></li>
					<li><a href="/documentation/">Docs</a></li>
					<li><a href="">Help &amp; Support</a></li>
					<li><a href="">Blog</a></li>
					<li><a href="">Get Involved</a></li>
				</ul>
			</div>
		</div>
	</div>
</div>
  <main class="refguide">
    <div class="row">

      <div class="medium-3 columns sideNav">
        <h4>Reference Guide</h4>
        <div id="dtkVersion">
          <label for="refver">Dojo Version</label>
          <select id="refver" name="refver">
            <option value="1.6">1.6</option>
            <option value="1.7">1.7</option>
            <option value="1.8">1.8</option>
            <option value="1.9">1.9</option>
            <option value="1.10" selected="selected">1.10</option>
          </select>
        </div>
        <ul>
          <li><a href="../index.html">Startpage</a></li>
          <li><a href="../dojo/index.html">Dojo</a></li>
          <li><a href="../dijit/index.html">Dijit</a></li>
          <li><a href="../dojox/index.html">DojoX</a></li>
        </ul>
        <ul>
<li><a class="reference internal" href="#">The Dojo Loader</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#dojo-js">dojo.js</a></li>
<li><a class="reference internal" href="#configuration-feature-detection">Configuration/Feature Detection</a><ul>
<li><a class="reference internal" href="#configuration">Configuration</a></li>
<li><a class="reference internal" href="#feature-detection">Feature Detection</a></li>
<li><a class="reference internal" href="#options-features">Options/Features</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-amd-api">The AMD API</a></li>
<li><a class="reference internal" href="#module-identifiers">Module Identifiers</a><ul>
<li><a class="reference internal" href="#relative-module-identifiers">Relative Module Identifiers</a></li>
<li><a class="reference internal" href="#context-sensitive-require">Context-sensitive require</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-script-injection">Generic Script Injection</a></li>
<li><a class="reference internal" href="#alias-modules">Alias Modules</a></li>
<li><a class="reference internal" href="#map-config">Map Config</a></li>
<li><a class="reference internal" href="#normalizing-module-identifiers">Normalizing Module Identifiers</a><ul>
<li><a class="reference internal" href="#normalization-examples">Normalization Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#relocating-module-namespaces">Relocating Module Namespaces</a></li>
<li><a class="reference internal" href="#utility-functions">Utility Functions</a></li>
<li><a class="reference internal" href="#commonjs-require-exports-and-module">CommonJS require, exports, and module</a></li>
<li><a class="reference internal" href="#plugins">Plugins</a></li>
<li><a class="reference internal" href="#window-load-detection">Window Load Detection</a></li>
<li><a class="reference internal" href="#the-micro-event-api">The Micro Event API</a></li>
<li><a class="reference internal" href="#error-reporting">Error Reporting</a></li>
<li><a class="reference internal" href="#debugging">Debugging</a></li>
<li><a class="reference internal" href="#tracing">Tracing</a></li>
<li><a class="reference internal" href="#non-browser-environments">Non-browser Environments</a></li>
<li><a class="reference internal" href="#the-legacy-api">The Legacy API</a></li>
<li><a class="reference internal" href="#modes-of-operation">Modes of Operation</a><ul>
<li><a class="reference internal" href="#legacy-synchronous-mode">Legacy Synchronous Mode</a></li>
<li><a class="reference internal" href="#legacy-cross-domain-mode">Legacy Cross Domain Mode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuration-reference">Configuration Reference</a><ul>
<li><a class="reference internal" href="#configuration-variables">Configuration Variables</a></li>
<li><a class="reference internal" href="#default-configuration">Default Configuration</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        

            <div id="searchbox" style="display: none">
                <h3>Quick search</h3>
                <form class="search" action="../search.html" method="get">
                    <input type="text" name="q" size="18" />
                    <input type="submit" value="Go" />
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                 </form>
                 <p class="searchtip" style="font-size: 90%">
                     Enter search terms or a module, class or function name.
                 </p>
            </div>
      </div>
      <div class="medium-9 columns content">
        
  <div class="section" id="the-dojo-loader">
<span id="loader-amd"></span><h1><a class="toc-backref" href="#id1">The Dojo Loader</a><a class="headerlink" href="#the-dojo-loader" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Rawld Gill</td>
</tr>
<tr class="field-even field"><th class="field-name">Editors:</th><td class="field-body">Colin Snover, Kenneth G. Franqueiro</td>
</tr>
<tr class="field-odd field"><th class="field-name">Project owner:</th><td class="field-body">Rawld Gill</td>
</tr>
<tr class="field-even field"><th class="field-name">since:</th><td class="field-body">1.7.0</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#the-dojo-loader" id="id1">The Dojo Loader</a><ul>
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li>
<li><a class="reference internal" href="#dojo-js" id="id3">dojo.js</a></li>
<li><a class="reference internal" href="#configuration-feature-detection" id="id4">Configuration/Feature Detection</a></li>
<li><a class="reference internal" href="#the-amd-api" id="id5">The AMD API</a></li>
<li><a class="reference internal" href="#module-identifiers" id="id6">Module Identifiers</a></li>
<li><a class="reference internal" href="#generic-script-injection" id="id7">Generic Script Injection</a></li>
<li><a class="reference internal" href="#alias-modules" id="id8">Alias Modules</a></li>
<li><a class="reference internal" href="#map-config" id="id9">Map Config</a></li>
<li><a class="reference internal" href="#normalizing-module-identifiers" id="id10">Normalizing Module Identifiers</a></li>
<li><a class="reference internal" href="#relocating-module-namespaces" id="id11">Relocating Module Namespaces</a></li>
<li><a class="reference internal" href="#utility-functions" id="id12">Utility Functions</a></li>
<li><a class="reference internal" href="#commonjs-require-exports-and-module" id="id13">CommonJS require, exports, and module</a></li>
<li><a class="reference internal" href="#plugins" id="id14">Plugins</a></li>
<li><a class="reference internal" href="#window-load-detection" id="id15">Window Load Detection</a></li>
<li><a class="reference internal" href="#the-micro-event-api" id="id16">The Micro Event API</a></li>
<li><a class="reference internal" href="#error-reporting" id="id17">Error Reporting</a></li>
<li><a class="reference internal" href="#debugging" id="id18">Debugging</a></li>
<li><a class="reference internal" href="#tracing" id="id19">Tracing</a></li>
<li><a class="reference internal" href="#non-browser-environments" id="id20">Non-browser Environments</a></li>
<li><a class="reference internal" href="#the-legacy-api" id="id21">The Legacy API</a></li>
<li><a class="reference internal" href="#modes-of-operation" id="id22">Modes of Operation</a></li>
<li><a class="reference internal" href="#configuration-reference" id="id23">Configuration Reference</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id2">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Dojo loader includes two APIs:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://github.com/amdjs/amdjs-api/wiki/AMD">The Asynchronous Module Definition (AMD) API</a> (&#8220;AMD API&#8221;)</li>
<li>The legacy dojo API which consists of <code class="docutils literal"><span class="pre">dojo.require()</span></code>, <code class="docutils literal"><span class="pre">dojo.provide()</span></code>, <code class="docutils literal"><span class="pre">dojo.requireIf()</span></code>,
<code class="docutils literal"><span class="pre">dojo.requireAfterIf()</span></code>, <code class="docutils literal"><span class="pre">dojo.platformRequire()</span></code>, and <code class="docutils literal"><span class="pre">dojo.requireLocalization()</span></code> (&#8220;legacy loader API&#8221;)</li>
</ul>
</div></blockquote>
<p>The AMD API is new for Dojo 1.7. It is the same API implemented by <a class="reference external" href="http://requirejs.org">RequireJS</a>, <a class="reference external" href="https://github.com/unscriptable/curl">curl</a>, and <a class="reference external" href="http://bdframework.org/bdLoad/">bdLoad</a> (the dojo implementation is an
adoption of bdLoad). This exciting new standard for writing and loading modules dramatically improves code
portability and interoperability. Equally important, it allows modules to be loaded asynchronously, which provides two
key benefits versus the old synchronous API:</p>
<blockquote>
<div><ul class="simple">
<li>Modules can be downloaded asynchronously and concurrently, thereby decreasing page load times up to 10x.</li>
<li>Hacks such as <code class="docutils literal"><span class="pre">debugAtAllCosts</span></code> are no longer needed in order to provide informative debugging (e.g. stack traces)
in all browsers.</li>
</ul>
</div></blockquote>
<p>While each loader offers a different set of extra features, the core API of all of these loaders is compatible and most
of the tutorial material for any one loader is applicable to the others.</p>
<p>In addition to the core loader APIs, the new Dojo loader includes several other useful features:</p>
<blockquote>
<div><ul class="simple">
<li>Multiple platform support: By default, the Dojo loader includes configurations for the browser, <a class="reference external" href="http://nodejs.org">node.js</a>, and <a class="reference external" href="http://www.mozilla.org/rhino/">Rhino</a>. Environment-specific configuration files are
typically less than 100 lines of code and can be easily written to extend Dojo support to other JavaScript
environments (see <a class="reference internal" href="#non-browser-environments">Non-browser Environments</a>).</li>
<li><a class="reference external" href="http://github.com/phiggins42/has.js">has.js</a> API: The Dojo loader implements the has.js API, and uses that API to bracket several loader features. In
conjunction with the Dojo build system, this allows for loader code to be reduced to about 3K (minimized and
gzipped). This makes the Dojo loader the smallest fully-compatible AMD loader currently available.</li>
<li>Configuration API: The loader includes a configuration API that may be leveraged by client applications, allowing
program designs that have exactly one entry vector for user configuration.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="dojo-js">
<h2><a class="toc-backref" href="#id3">dojo.js</a><a class="headerlink" href="#dojo-js" title="Permalink to this headline">¶</a></h2>
<p>Prior to v1.7, dojo.js caused both the Dojo loader and the Dojo library bootstrap to be defined. This design has been
improved so that dojo.js now holds the loader and nothing else. In fact, it is now possible to use Dojo&#8217;s loader
without any of the Dojo library. For backwards-compatibility, the loader starts up in synchronous mode by default,
which loads the Dojo base API automatically:</p>
<div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;path/to/dojo/dojo.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script&gt;</span>
  <span class="c1">// the dojo base API is available here</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="html"><textarea style="display:none">&lt;script src=&quot;path/to/dojo/dojo.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // the dojo base API is available here
&lt;/script&gt;</textarea></div><p>To put the loader in the AMD mode, set the <code class="docutils literal"><span class="pre">async</span></code> configuration variable to truthy:</p>
<div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">data-dojo-config=</span><span class="s">&quot;async:1&quot;</span> <span class="na">src=</span><span class="s">&quot;path/to/dojo/dojo.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script&gt;</span>
  <span class="c1">// ATTENTION: nothing but the AMD API is available here</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="html"><textarea style="display:none">&lt;script data-dojo-config=&quot;async:1&quot; src=&quot;path/to/dojo/dojo.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // ATTENTION: nothing but the AMD API is available here
&lt;/script&gt;</textarea></div><p>Note that you can only set the <code class="docutils literal"><span class="pre">async</span></code> flag <em>before</em> dojo.js is loaded, and that in AMD mode, <strong>neither Dojo nor any
other library is automatically loaded</strong> - it is entirely up to the application to decide which modules/libraries to
load.</p>
</div>
<div class="section" id="configuration-feature-detection">
<span id="loader-amd-configuration"></span><h2><a class="toc-backref" href="#id4">Configuration/Feature Detection</a><a class="headerlink" href="#configuration-feature-detection" title="Permalink to this headline">¶</a></h2>
<div class="section" id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h3>
<p>There are three ways to pass configuration data to the loader:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Before the loader is defined, via the global <code class="docutils literal"><span class="pre">dojoConfig</span></code> object (See also <a class="reference internal" href="../dojo/config.html#dojo-config"><span>dojo/config</span></a>)</li>
<li>On the <code class="docutils literal"><span class="pre">&lt;script&gt;</span></code> element for the loader, via the <code class="docutils literal"><span class="pre">data-dojo-config</span></code> attribute</li>
<li>After the loader is defined, via the global <code class="docutils literal"><span class="pre">require</span></code> function</li>
</ol>
</div></blockquote>
<p>Configuration data is always provided as a standard JavaScript object. When the object is passed as a
<code class="docutils literal"><span class="pre">data-dojo-config</span></code> attribute, the opening and closing curly-brackets should be omitted from the object expression
(just as with <code class="docutils literal"><span class="pre">data-dojo-props</span></code>). Using <code class="docutils literal"><span class="pre">data-dojo-config</span></code> looks like this:</p>
<div class="highlight"><pre><span class="nt">&lt;script</span>
<span class="nt">  </span><span class="na">data-dojo-config=</span><span class="s">&quot;async:true, cacheBust:new Date(), waitSeconds:5&quot;</span>
  <span class="na">src=</span><span class="s">&quot;path/to/dojo/dojo.js&quot;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="html"><textarea style="display:none">&lt;script
  data-dojo-config=&quot;async:true, cacheBust:new Date(), waitSeconds:5&quot;
  src=&quot;path/to/dojo/dojo.js&quot;&gt;
&lt;/script&gt;</textarea></div><p>Using <code class="docutils literal"><span class="pre">dojoConfig</span></code> looks like this:</p>
<div class="highlight"><pre><span class="nt">&lt;script&gt;</span>
  <span class="kd">var</span> <span class="nx">dojoConfig</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">async</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span>
    <span class="nx">cacheBust</span><span class="o">:</span><span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span>
    <span class="nx">waitSeconds</span><span class="o">:</span><span class="mi">5</span>
  <span class="p">};</span>
<span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;path/to/dojo/dojo.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="html"><textarea style="display:none">&lt;script&gt;
  var dojoConfig = {
    async:true,
    cacheBust:new Date(),
    waitSeconds:5
  };
&lt;/script&gt;
&lt;script src=&quot;path/to/dojo/dojo.js&quot;&gt;&lt;/script&gt;</textarea></div><p>Using the <code class="docutils literal"><span class="pre">require</span></code> function looks like this:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">({</span>
  <span class="nx">cacheBust</span><span class="o">:</span><span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span>
  <span class="nx">waitSeconds</span><span class="o">:</span><span class="mi">5</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require({
  cacheBust:new Date(),
  waitSeconds:5
});</textarea></div><p>Note that the <code class="docutils literal"><span class="pre">async</span></code> flag and any has.js tests that are defined or required by the loader at startup <strong>cannot</strong> be
set using the <code class="docutils literal"><span class="pre">require</span></code> function, and must go in a <code class="docutils literal"><span class="pre">dojoConfig</span></code> or <code class="docutils literal"><span class="pre">data-dojo-config</span></code> object.</p>
<p>For backwards compatibility, the deprecated variable <code class="docutils literal"><span class="pre">djConfig</span></code> can be used instead of <code class="docutils literal"><span class="pre">dojoConfig</span></code>. Note, however,
that if both <code class="docutils literal"><span class="pre">dojoConfig</span></code> and <code class="docutils literal"><span class="pre">djConfig</span></code> are defined, <code class="docutils literal"><span class="pre">djConfig</span></code> is ignored. Also note that if either
<code class="docutils literal"><span class="pre">dojoConfig</span></code> or <code class="docutils literal"><span class="pre">djConfig</span></code> exist <em>and</em> the <code class="docutils literal"><span class="pre">data-dojo-config</span></code> attribute is defined, both <code class="docutils literal"><span class="pre">dojoConfig</span></code> and
<code class="docutils literal"><span class="pre">data-dojo-config</span></code> are consumed, with values in <code class="docutils literal"><span class="pre">data-dojo-config</span></code> taking precedence over those in <code class="docutils literal"><span class="pre">dojoConfig</span></code>.</p>
<p>The configuration object can also be used to set arbitrary, application-specific configuration data. All properties of a
configuration object are shallow copied to <code class="docutils literal"><span class="pre">require.rawConfig</span></code>; values that the loader recognizes are also added to
<code class="docutils literal"><span class="pre">require.config</span></code>. Because these are shallow copies, if you need to mix-in properties of a sub-object instead of having
that object replaced completely, the loader includes a &#8220;config&#8221; event that is signaled via <a class="reference internal" href="#the-micro-event-api">the micro event API</a>
whenever configuration data is received.</p>
<p>The &#8220;config&#8221; event passes two arguments to any listeners:</p>
<blockquote>
<div><ul class="simple">
<li>config: the configuration object passed to the loader that triggered the &#8220;config&#8221; event</li>
<li>rawConfig: the value of <code class="docutils literal"><span class="pre">require.rawConfig</span></code></li>
</ul>
</div></blockquote>
<p>The various configuration variables that apply to the loader are discussed in detail in their relevant sections. The
section <a class="reference internal" href="#configuration-reference">Configuration Reference</a> includes a list of all reserved configuration variables.</p>
</div>
<div class="section" id="feature-detection">
<h3>Feature Detection<a class="headerlink" href="#feature-detection" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../dojo/has.html#dojo-has"><span>has.js</span></a> is a standard API that allows feature detection to be separated from feature-dependent code
branching and enables the build system to create platform-optimized versions of applications.</p>
<p>Here&#8217;s an example of adding a test, and then later using that test:</p>
<div class="highlight"><pre><span class="nx">has</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s2">&quot;dom-addeventlistener&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="nx">has</span><span class="p">(</span><span class="s2">&quot;dom-addeventlistener&quot;</span><span class="p">)){</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;click&quot;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
<span class="p">}</span><span class="k">else</span><span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">(</span><span class="s2">&quot;onclick&quot;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">has.add(&quot;dom-addeventlistener&quot;, !!document.addEventListener);

if(has(&quot;dom-addeventlistener&quot;)){
  node.addEventListener(&quot;click&quot;, handler);
}else{
  node.attachEvent(&quot;onclick&quot;, handler);
}</textarea></div><p>At build time, with an appropriate build profile, this code is transformed to:</p>
<div class="highlight"><pre><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">has</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s2">&quot;dom-addeventlistener&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;click&quot;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
<span class="p">}</span><span class="k">else</span><span class="p">{</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">(</span><span class="s2">&quot;onclick&quot;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">0 &amp;&amp; has.add(&quot;dom-addeventlistener&quot;, !!document.addEventListener);

if(1){
  node.addEventListener(&quot;click&quot;, handler);
}else{
  node.attachEvent(&quot;onclick&quot;, handler);
}</textarea></div><p>When transformed code is then passed to a minifier with dead code removal, the final output becomes:</p>
<div class="highlight"><pre><span class="nx">node</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;click&quot;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">node.addEventListener(&quot;click&quot;, handler);</textarea></div><p>When these techniques are applied to heavily branched code, very large space savings are possible. These savings are
particularly important in mobile environments where bandwidth and cache size are more limited.</p>
<p>There are two features Dojo&#8217;s implementation of has.js has that the standard has.js code does not:</p>
<blockquote>
<div><ul class="simple">
<li>the cache of tests is publicly exposed at <code class="docutils literal"><span class="pre">has.cache</span></code></li>
<li>the function <code class="docutils literal"><span class="pre">has.add</span></code> includes an optional fourth parameter, <code class="docutils literal"><span class="pre">force</span></code>, that can be used to overwrite an existing
test. (Normally, the first defined value is always used, like a constant.)</li>
</ul>
</div></blockquote>
<p>The Dojo loader initializes the has cache with several tests (see <a class="reference internal" href="#default-configuration">Default Configuration</a> for a list of these
tests). <code class="docutils literal"><span class="pre">dojoConfig</span></code> and <code class="docutils literal"><span class="pre">data-dojo-config</span></code> can override any of these, and any configuration object can add more
tests by specifying a <code class="docutils literal"><span class="pre">has</span></code> configuration property. For example:</p>
<div class="highlight"><pre><span class="nt">&lt;script&gt;</span>
  <span class="kd">var</span> <span class="nx">dojoConfig</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">has</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">&quot;config-tlmSiblingOfDojo&quot;</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span>
      <span class="s2">&quot;myApp-someFeature&quot;</span><span class="o">:</span><span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="html"><textarea style="display:none">&lt;script&gt;
  var dojoConfig = {
    has: {
      &quot;config-tlmSiblingOfDojo&quot;:0,
      &quot;myApp-someFeature&quot;:1
    }
  };
&lt;/script&gt;</textarea></div><p>A test can also be defined as a function, which will be executed the first time the value of the feature is requested
via a <code class="docutils literal"><span class="pre">has</span></code> call:</p>
<div class="highlight"><pre><span class="nt">&lt;script&gt;</span>
  <span class="kd">var</span> <span class="nx">dojoConfig</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">has</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">&quot;myApp-someFeature&quot;</span><span class="o">:</span><span class="kd">function</span><span class="p">(){</span>
        <span class="k">return</span> <span class="o">!!</span><span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="html"><textarea style="display:none">&lt;script&gt;
  var dojoConfig = {
    has: {
      &quot;myApp-someFeature&quot;:function(){
        return !!document.addEventListener;
      }
    }
  };
&lt;/script&gt;</textarea></div><p>Since has tests can be used very much like configuration variables, the loader&#8217;s configuration API applies <code class="docutils literal"><span class="pre">has.add</span></code>
to all configuration variables it receives, prefixing the configuration variable name with &#8220;config-&#8221;. For example:</p>
<div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">data-dojo-config=</span><span class="s">&quot;tlmSiblingOfDojo:0&quot;</span> <span class="na">src=</span><span class="s">&quot;path/to/dojo/dojo.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="html"><textarea style="display:none">&lt;script data-dojo-config=&quot;tlmSiblingOfDojo:0&quot; src=&quot;path/to/dojo/dojo.js&quot;&gt;&lt;/script&gt;</textarea></div><p>This code will result in a has test named &#8220;config-tlmSiblingOfDojo&#8221; with a value of 0.</p>
</div>
<div class="section" id="options-features">
<h3>Options/Features<a class="headerlink" href="#options-features" title="Permalink to this headline">¶</a></h3>
<p>The following table provides a list of options that are leveraged within the loader.  The first column is the Option/Feature as defined within the loader, the second options is whether this is a detected feature (via <code class="docutils literal"><span class="pre">has.add()</span></code>) or if it is just an option and its default value.  With &#8220;unbuilt&#8221; source, all the features and options are available.  If the loader has been built, then some of these features may have been set as <code class="docutils literal"><span class="pre">staticHasFeatures</span></code> and not be configurable anymore.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="14%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Feature</th>
<th class="head">Default Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>dojo-trace-api</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>dojo-sync-loader</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>dojo-config-api</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>dojo-cdn</td>
<td>False</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>dojo-requirejs-api</td>
<td>False</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>dojo-test-sniff</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>dojo-combo-api</td>
<td>False</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>dojo-undef-api</td>
<td>False</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>config-tlmSiblingOfDojo</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>config-dojo-loader-catches</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>dojo-inject-api</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>config-stripStrict</td>
<td>False</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>dojo-timeout-api</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>dojo-log-api</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>dojo-amd-factory-scan</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>dojo-publish-privates</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>dojo-built</td>
<td>False</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>dojo-loader</td>
<td>True</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>host-node</td>
<td><em>Detected</em></td>
<td>Environment is running on the the NodeJS platform</td>
</tr>
<tr class="row-odd"><td>host-rhino</td>
<td><em>Detected</em></td>
<td>Environment is running on the Rhino platform</td>
</tr>
<tr class="row-even"><td>dojo-xhr-factory</td>
<td><em>Detected</em></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>dojo-force-activex-xhr</td>
<td><em>Detected</em></td>
<td>Force XHR provider to use ActiveX API (MSXMLHTTP).</td>
</tr>
<tr class="row-even"><td>native-xhr</td>
<td><em>Detected</em></td>
<td>Browser has native XHR API, XMLHttpRequest.</td>
</tr>
<tr class="row-odd"><td>dojo-gettext-api</td>
<td><em>Detected</em></td>
<td>Dojo provides API for retrieving text resource contents from a URL.</td>
</tr>
<tr class="row-even"><td>dojo-loader-eval-hint-url</td>
<td><em>Detected</em></td>
<td>Module location should be used as source hint during eval rather than module identifier.</td>
</tr>
<tr class="row-odd"><td>ie-event-behavior</td>
<td><em>Detected</em></td>
<td>Browser supports legacy IE event behaviour API (attachEvent versus attachEventListener).</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="the-amd-api">
<h2><a class="toc-backref" href="#id5">The AMD API</a><a class="headerlink" href="#the-amd-api" title="Permalink to this headline">¶</a></h2>
<p>The AMD API is the preferred loader API and is exposed through two global functions, <code class="docutils literal"><span class="pre">require</span></code> and <code class="docutils literal"><span class="pre">define</span></code>. Both
functions are normally asynchronous. When running in legacy loader API mode, however, they may operate synchronously in
order to allow AMD modules to be accessed by legacy code.</p>
<p><code class="docutils literal"><span class="pre">require</span></code> is used to configure the loader and load AMD modules. It has the following signature:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">(</span>
  <span class="nx">configuration</span><span class="p">,</span> <span class="c1">// (optional; object) configuration object</span>
  <span class="nx">dependencies</span><span class="p">,</span>  <span class="c1">// (optional; array of strings) list of module identifiers to load before calling callback</span>
  <span class="nx">callback</span>       <span class="c1">// (optional; function) function to call when dependencies are loaded</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">undefined</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require(
  configuration, // (optional; object) configuration object
  dependencies,  // (optional; array of strings) list of module identifiers to load before calling callback
  callback       // (optional; function) function to call when dependencies are loaded
) -&gt; undefined</textarea></div><p>If a <code class="docutils literal"><span class="pre">configuration</span></code> object is provided, it is passed to the configuration API as described in <a class="reference internal" href="#configuration">Configuration</a>. Next,
the dependencies listed in <code class="docutils literal"><span class="pre">dependencies</span></code> (if any) are resolved. Finally, <code class="docutils literal"><span class="pre">callback</span></code> (if any) is executed with the
resolved dependencies passed in as arguments.</p>
<p>Normal use of <code class="docutils literal"><span class="pre">require</span></code> looks like this:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">([</span> <span class="s2">&quot;my/app&quot;</span><span class="p">,</span> <span class="s2">&quot;dojo&quot;</span> <span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">app</span><span class="p">,</span> <span class="nx">dojo</span><span class="p">){</span>
  <span class="c1">// do something with app and dojo...</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require([ &quot;my/app&quot;, &quot;dojo&quot; ], function(app, dojo){
  // do something with app and dojo...
});</textarea></div><p>There is also an alternative <code class="docutils literal"><span class="pre">require</span></code> syntax. It has the following signature:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">(</span>
  <span class="nx">moduleId</span> <span class="c1">// (string) a module identifier</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">any</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require(
  moduleId // (string) a module identifier
) -&gt; any</textarea></div><p>This alternative <code class="docutils literal"><span class="pre">require</span></code> syntax can be used if you are certain the module referenced by <code class="docutils literal"><span class="pre">moduleId</span></code> has already
been defined and loaded. It will return the requested module. If the module is not loaded, it will throw an Error. <em>This
syntax is not recommended because it can lead to confusing dependency chains.</em></p>
<p><code class="docutils literal"><span class="pre">define</span></code> is very similar to <code class="docutils literal"><span class="pre">require</span></code> and is used to define AMD modules. It has the following signature:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">(</span>
  <span class="nx">moduleId</span><span class="p">,</span>      <span class="c1">// (optional; string) an explicit module identifier naming the module being defined</span>
  <span class="nx">dependencies</span><span class="p">,</span>  <span class="c1">// (optional; array of strings) list of module identifiers to load before calling factory</span>
  <span class="nx">factory</span>        <span class="c1">// (function or value) the value of the module, or a function that returns the value of the module</span>
<span class="p">)</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">define(
  moduleId,      // (optional; string) an explicit module identifier naming the module being defined
  dependencies,  // (optional; array of strings) list of module identifiers to load before calling factory
  factory        // (function or value) the value of the module, or a function that returns the value of the module
)</textarea></div><p>If <code class="docutils literal"><span class="pre">factory</span></code> is a function, the defined module value is the return value of the function; otherwise, the module value
is <code class="docutils literal"><span class="pre">factory</span></code>. Regardless of whether or not <code class="docutils literal"><span class="pre">factory</span></code> is a function, dependencies are always fully resolved before
the module is defined.</p>
<p>If only the <code class="docutils literal"><span class="pre">factory</span></code> parameter is given and it is a function, special semantics are implied; these are covered in
<a class="reference internal" href="#commonjs-require-exports-and-module">CommonJS require, exports, and module</a>.</p>
<p><strong>moduleId should not be provided.</strong> This parameter is largely a historical artifact of early AMD loaders. So long as
there is <strong>exactly</strong> one module defined by any particular resource, the loader will automatically derive the correct
module identifier from the one given in the dependency list that caused it to be loaded. For example, when calling
<code class="docutils literal"><span class="pre">require([&quot;mathLib/arithmetic&quot;])</span></code>, the loader knows that the loaded module has a <code class="docutils literal"><span class="pre">moduleId</span></code> of
&#8220;mathLib/arithmetic&#8221;.</p>
<p>It is also possible to load a script as a dependency with no <code class="docutils literal"><span class="pre">define</span></code> calls at all, in which case the resolved value
will be <code class="docutils literal"><span class="pre">undefined</span></code>. See <a class="reference internal" href="#generic-script-injection">Generic Script Injection</a> for more information.</p>
<p><code class="docutils literal"><span class="pre">define</span></code> has two additional important characteristics that may not be immediately obvious:</p>
<blockquote>
<div><ul class="simple">
<li>Module creation is lazy and asynchronous, and does not occur immediately when <code class="docutils literal"><span class="pre">define</span></code> is called. This means that
<code class="docutils literal"><span class="pre">factory</span></code> is not executed, and any dependencies of the module will not be resolved, until some running code
actually requires the module.</li>
<li>Once a module value has been entered into the module namespace, it is not recomputed each time it is demanded. On a
practical level, this means that <code class="docutils literal"><span class="pre">factory</span></code> is only invoked once, and the returned value is cached and shared
among all code that uses a given module. (Note: the dojo loader includes the nonstandard function <code class="docutils literal"><span class="pre">require.undef</span></code>,
which undefines a module value.)</li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal"><span class="pre">dependencies</span></code> and <code class="docutils literal"><span class="pre">callback</span></code> parameters in the <code class="docutils literal"><span class="pre">require</span></code> function work exactly like the <code class="docutils literal"><span class="pre">dependencies</span></code> and
<code class="docutils literal"><span class="pre">factory</span></code> parameters in the <code class="docutils literal"><span class="pre">define</span></code> function. For example:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">(</span>
  <span class="p">[</span><span class="s2">&quot;dijit/layout/TabContainer&quot;</span><span class="p">,</span> <span class="s2">&quot;bd/widgets/stateButton&quot;</span><span class="p">],</span>
  <span class="kd">function</span><span class="p">(</span><span class="nx">TabContainer</span><span class="p">,</span> <span class="nx">stateButton</span><span class="p">){</span>
    <span class="c1">// do something with TabContainer and stateButton...</span>
  <span class="p">}</span>
<span class="p">);</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require(
  [&quot;dijit/layout/TabContainer&quot;, &quot;bd/widgets/stateButton&quot;],
  function(TabContainer, stateButton){
    // do something with TabContainer and stateButton...
  }
);</textarea></div><p>...and...</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">(</span>
  <span class="p">[</span><span class="s2">&quot;dijit/layout/TabContainer&quot;</span><span class="p">,</span> <span class="s2">&quot;bd/widgets/stateButton&quot;</span><span class="p">],</span>
  <span class="kd">function</span><span class="p">(</span><span class="nx">TabContainer</span><span class="p">,</span> <span class="nx">stateButton</span><span class="p">){</span>
    <span class="c1">// do something with TabContainer and stateButton...</span>
    <span class="k">return</span> <span class="nx">definedValue</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">);</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">define(
  [&quot;dijit/layout/TabContainer&quot;, &quot;bd/widgets/stateButton&quot;],
  function(TabContainer, stateButton){
    // do something with TabContainer and stateButton...
    return definedValue;
  }
);</textarea></div><p>...both gain access to the values of the <code class="docutils literal"><span class="pre">dijit/layout/TabContainer</span></code> and <code class="docutils literal"><span class="pre">bd/widgets/stateButton</span></code> modules. The
difference between these two calls is that the latter is expected to also provide a value of its own, whereas the former
simply loads modules.</p>
</div>
<div class="section" id="module-identifiers">
<span id="loader-amd-module-identifiers"></span><h2><a class="toc-backref" href="#id6">Module Identifiers</a><a class="headerlink" href="#module-identifiers" title="Permalink to this headline">¶</a></h2>
<p>Module identifiers look like file system paths (for example, &#8220;dijit/form/Button&#8221;). These identifiers are normalized to
absolute URLs (in browsers) or file paths (in server-side environments) in order to find and load the source code that
defines the module.</p>
<p>The following <a class="reference internal" href="#configuration">Configuration</a> variables control how module identifiers are mapped to URLs:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">baseUrl</span></code>: (string) a path to prepend to a computed path if the computed path is relative as described by the
process below. If defined, the has feature <code class="docutils literal"><span class="pre">config-tlmSiblingOfDojo</span></code> is false; otherwise, it is true.</li>
<li><code class="docutils literal"><span class="pre">paths</span></code>: (object) a map from a module identifier fragment to a path fragment. Module fragments are always matched
starting from the beginning of a module identifier. <em>When matching paths, the most specific match wins.</em> For
example, &#8220;a/b/c&#8221; is more specific than &#8220;a&#8221; or &#8220;a/b&#8221;.</li>
<li><code class="docutils literal"><span class="pre">aliases</span></code>: (object) a globally applied map from a module identifier to another module identifier.  See <a class="reference internal" href="#alias-modules">Alias
Modules</a> for more information.</li>
<li><code class="docutils literal"><span class="pre">map</span></code>: (object) module mapping with the ability to be applied only to specific modules. See <a class="reference internal" href="#map-config">Map Config</a> for more
information.</li>
<li>the has feature <code class="docutils literal"><span class="pre">config-tlmSiblingOfDojo</span></code>: if truthy, then non-package top-level modules not mentioned in
<code class="docutils literal"><span class="pre">paths</span></code> are assumed to be siblings of the dojo package; otherwise, they are assumed to be relative to <code class="docutils literal"><span class="pre">baseUrl</span></code>.</li>
<li><code class="docutils literal"><span class="pre">packages</span></code>: (array of package objects) A list of explicitly defined packages. dojo and dijit are both examples of
packages. A package object contains four properties:<ul>
<li><code class="docutils literal"><span class="pre">name</span></code>: (string) the name of the package (e.g. &#8220;myApp&#8221;)</li>
<li><code class="docutils literal"><span class="pre">location</span></code>: (string) the path to the directory where the package resides (e.g. &#8220;path/to/myApp&#8221;)</li>
<li><code class="docutils literal"><span class="pre">main</span></code>: (optional; string) the module identifier implied when a module identifier that is equivalent to just the
package name is given; defaults to &#8220;main&#8221;. (e.g. &#8220;dojo&#8221; =&gt; &#8220;dojo/main&#8221;)</li>
<li><code class="docutils literal"><span class="pre">packageMap</span></code>: (optional; object) a map that allows package names to be aliased to other locations for this
particular package only. See <a class="reference internal" href="#relocating-module-namespaces">Relocating Module Namespaces</a> for more information. (Note: this feature is
currently exclusive to the Dojo loader.)</li>
</ul>
</li>
</ul>
</div></blockquote>
<div class="section" id="relative-module-identifiers">
<h3>Relative Module Identifiers<a class="headerlink" href="#relative-module-identifiers" title="Permalink to this headline">¶</a></h3>
<p>Module identifiers in the <code class="docutils literal"><span class="pre">dependencies</span></code> array of a module definition can also be relative to the current module. For
example:</p>
<div class="highlight"><pre><span class="c1">// this is &quot;myPackage/myModule/mySubmodule&quot;</span>
<span class="nx">define</span><span class="p">(</span>
  <span class="p">[</span><span class="s2">&quot;myPackage/utils&quot;</span><span class="p">,</span> <span class="s2">&quot;myPackage/myModule/mySubmodule2&quot;</span><span class="p">],</span>
  <span class="kd">function</span><span class="p">(</span><span class="nx">utils</span><span class="p">,</span> <span class="nx">submodule</span><span class="p">){</span>
    <span class="c1">// do something spectacular</span>
  <span class="p">}</span>
<span class="p">);</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">// this is &quot;myPackage/myModule/mySubmodule&quot;
define(
  [&quot;myPackage/utils&quot;, &quot;myPackage/myModule/mySubmodule2&quot;],
  function(utils, submodule){
    // do something spectacular
  }
);</textarea></div><p>Could be rewritten as:</p>
<div class="highlight"><pre><span class="c1">// this is &quot;myPackage/myModule/mySubmodule&quot;</span>
<span class="nx">define</span><span class="p">(</span>
  <span class="p">[</span><span class="s2">&quot;../utils&quot;</span><span class="p">,</span> <span class="s2">&quot;./mySubmodule2&quot;</span><span class="p">],</span>
  <span class="kd">function</span><span class="p">(</span><span class="nx">utils</span><span class="p">,</span> <span class="nx">submodule</span><span class="p">){</span>
  <span class="c1">// do something spectacular</span>
  <span class="p">}</span>
<span class="p">);</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">// this is &quot;myPackage/myModule/mySubmodule&quot;
define(
  [&quot;../utils&quot;, &quot;./mySubmodule2&quot;],
  function(utils, submodule){
  // do something spectacular
  }
);</textarea></div><p>&#8221;.&#8221; can be thought of as referring to the &#8220;directory&#8221; of the current module, and &#8221;..&#8221; as referring to the &#8220;parent
directory&#8221; of the current module.</p>
<p><strong>Note that relative module identifiers can only be used to refer to modules within a single package.</strong> That is, &#8221;../&#8221;
cannot be used to ascend to the top level in the module identifier.  So in the above example,
&#8221;../../someOtherPackage/otherModule&#8221; would not be valid.</p>
<p>It is highly recommended that relative module IDs be used by all packages to refer to their own modules, since otherwise
it is impossible to load two different packages with the same name (or two different versions of the same package). This
is explored further in <a class="reference internal" href="#relocating-module-namespaces">Relocating Module Namespaces</a>.</p>
</div>
<div class="section" id="context-sensitive-require">
<h3>Context-sensitive require<a class="headerlink" href="#context-sensitive-require" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s finish up one last detail about reference modules. Suppose we have a function that, depending on program flow,
needs to conditionally require and execute some code. For example:</p>
<div class="highlight"><pre><span class="c1">// this is &quot;myApp/topLevelHandlers&quot;</span>
<span class="nx">define</span><span class="p">([</span><span class="s2">&quot;dojo&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">dojo</span><span class="p">){</span>
  <span class="nx">dojo</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="nx">dojo</span><span class="p">.</span><span class="nx">byId</span><span class="p">(</span><span class="s2">&quot;debugButton&quot;</span><span class="p">),</span> <span class="s2">&quot;click&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">require</span><span class="p">([</span><span class="s2">&quot;myApp/perspectives/debug&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">perspective</span><span class="p">){</span>
      <span class="nx">perspective</span><span class="p">.</span><span class="nx">open</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">// this is &quot;myApp/topLevelHandlers&quot;
define([&quot;dojo&quot;], function(dojo){
  dojo.connect(dojo.byId(&quot;debugButton&quot;), &quot;click&quot;, function(){
    require([&quot;myApp/perspectives/debug&quot;], function(perspective){
      perspective.open();
    });
  });
});</textarea></div><p>This code is perfectly legal, but it can be better. Since this code is in the &#8220;myApp/topLevelHandlers&#8221; module, we should
be able to write &#8221;./perspectives/debug&#8221; instead of &#8220;myApp/perspectives/debug&#8221;. Unfortunately, the global <code class="docutils literal"><span class="pre">require</span></code>
function doesn&#8217;t know anything about reference modules, so if we try just changing the identifier string, it will
fail. What we need is a way to remember the reference module for later use. This is possible by specifying the module
identifier &#8220;require&#8221; in the dependency vector:</p>
<div class="highlight"><pre><span class="c1">// this is &quot;myApp/topLevelHandlers&quot;</span>
<span class="nx">define</span><span class="p">([</span><span class="s2">&quot;dojo&quot;</span><span class="p">,</span> <span class="s2">&quot;require&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">dojo</span><span class="p">,</span> <span class="nx">require</span><span class="p">){</span>
  <span class="nx">dojo</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="nx">dojo</span><span class="p">.</span><span class="nx">byId</span><span class="p">(</span><span class="s2">&quot;debugButton&quot;</span><span class="p">),</span> <span class="s2">&quot;click&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">require</span><span class="p">([</span><span class="s2">&quot;./perspectives/debug&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">perspective</span><span class="p">){</span>
      <span class="nx">perspective</span><span class="p">.</span><span class="nx">open</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">// this is &quot;myApp/topLevelHandlers&quot;
define([&quot;dojo&quot;, &quot;require&quot;], function(dojo, require){
  dojo.connect(dojo.byId(&quot;debugButton&quot;), &quot;click&quot;, function(){
    require([&quot;./perspectives/debug&quot;], function(perspective){
      perspective.open();
    });
  });
});</textarea></div><p>The <code class="docutils literal"><span class="pre">require</span></code> call is now executed on a local <code class="docutils literal"><span class="pre">require</span></code> function instead of the global one. The loader arranges for
the local <code class="docutils literal"><span class="pre">require</span></code> to resolve module identifiers with respect to the reference module that defines it. This local
<code class="docutils literal"><span class="pre">require</span></code> function is called a &#8220;context-sensitive require&#8221;.</p>
</div>
</div>
<div class="section" id="generic-script-injection">
<h2><a class="toc-backref" href="#id7">Generic Script Injection</a><a class="headerlink" href="#generic-script-injection" title="Permalink to this headline">¶</a></h2>
<p>An explicit path or URL to a script can be passed as a module identifier. In this case, the script is simply evaluated and the return value of that &#8220;module&#8221; is <code class="docutils literal"><span class="pre">undefined</span></code>. For example:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">([</span><span class="s2">&quot;http://acmecorp.com/stuff.js&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="c1">// etc.</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require([&quot;http://acmecorp.com/stuff.js&quot;], function(){
  // etc.
});</textarea></div><p>The loader interprets any of the following as a generic script identifier:</p>
<blockquote>
<div><ul class="simple">
<li>a string that starts with a protocol (e.g. &#8220;http:&#8221; or &#8220;https:&#8221;)</li>
<li>a string that starts with a slash (e.g., &#8220;/acmecorp.com/stuff&#8221;)</li>
<li>a string that ends in &#8221;.js&#8221;</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="alias-modules">
<h2><a class="toc-backref" href="#id8">Alias Modules</a><a class="headerlink" href="#alias-modules" title="Permalink to this headline">¶</a></h2>
<p>It is possible to create an alias from one module to another. An example of when module aliasing might be needed is the
common <code class="docutils literal"><span class="pre">text</span></code> plugin, which loads a text resource through the plugin API (see <a class="reference internal" href="#plugins">Plugins</a>). RequireJS defined this
module early on, and several libraries depend on the module as defined by RequireJS. Dojo&#8217;s implementation, while 100%
compatible with RequireJS&#8217;s implementation, is smaller and contains more features. It is possible to simply alias Dojo&#8217;s
text module like this:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">({</span>
  <span class="nx">aliases</span><span class="o">:</span><span class="p">[</span>
    <span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;dojo/text&quot;</span><span class="p">]</span>
  <span class="p">]</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require({
  aliases:[
    [&quot;text&quot;, &quot;dojo/text&quot;]
  ]
});</textarea></div><p>Now, when the module identifier &#8220;text&#8221; is demanded, the loader will normalize that module identifier to &#8220;dojo/text&#8221;. In
other words, given the configuration above, all of the following statements result in exactly the same module value
being returned:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">([</span><span class="s2">&quot;text&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">){</span> <span class="c1">//...</span>
<span class="nx">require</span><span class="p">([</span><span class="s2">&quot;dojo/text&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">){</span> <span class="c1">//...</span>
<span class="nx">define</span><span class="p">([</span><span class="s2">&quot;text&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">){</span> <span class="c1">//...</span>
<span class="nx">define</span><span class="p">([</span><span class="s2">&quot;dojo/text&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">){</span> <span class="c1">//...</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require([&quot;text&quot;], function(text){ //...
require([&quot;dojo/text&quot;], function(text){ //...
define([&quot;text&quot;], function(text){ //...
define([&quot;dojo/text&quot;], function(text){ //...</textarea></div><p>There is one particular scenario where using aliases is not the optimal solution.  Two different absolute module identifiers
as calculated after Step 6 of the <a class="reference internal" href="#normalizing-module-identifiers">Normalizing Module Identifiers</a> process will always result in two different modules
being instantiated - even if they normalize to the same path. This means you can&#8217;t solve this problem using
<code class="docutils literal"><span class="pre">paths</span></code>. For example, assuming <code class="docutils literal"><span class="pre">baseUrl</span></code> points to the dojo directory, you <strong>can&#8217;t</strong> alias &#8220;text&#8221; to &#8220;dojo/text&#8221;
like this:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">({</span>
  <span class="nx">paths</span><span class="o">:</span><span class="p">{</span>
    <span class="s2">&quot;text&quot;</span><span class="o">:</span><span class="s2">&quot;./text&quot;</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require({
  paths:{
    &quot;text&quot;:&quot;./text&quot;
  }
});</textarea></div><p>In this case, assuming no reference module, &#8220;text&#8221; is normalized to (&#8220;text&#8221;, &#8220;path/to/dojo/text.js&#8221;). Although
&#8220;path/to/dojo/text.js&#8221; has the same path as the module given by &#8220;dojo/text&#8221;, the loader will create two separate
instances of that module, which is probably not what you want. The only way to get two different module identifiers to
resolve to the same module value is to either write a module definition with an explicit module ID (not recommended) or
provide an aliases configuration.</p>
</div>
<div class="section" id="map-config">
<h2><a class="toc-backref" href="#id9">Map Config</a><a class="headerlink" href="#map-config" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">map</span></code> loader configuration option is similar to the <code class="docutils literal"><span class="pre">alias</span></code> option in that it allows you to alias module
identifiers but with more flexibility in terms of context and matching capabilities. The value of the <code class="docutils literal"><span class="pre">map</span></code> option
is an object whose keys define the context of the mapping and the values are the aliases. For example:</p>
<div class="highlight"><pre> <span class="nx">map</span><span class="o">:</span> <span class="p">{</span>
   <span class="s2">&quot;app/ModuleA&quot;</span><span class="o">:</span> <span class="p">{</span>
     <span class="s2">&quot;app/Widget&quot;</span><span class="o">:</span> <span class="s2">&quot;app/Widget_NEW&quot;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none"> map: {
   &quot;app/ModuleA&quot;: {
     &quot;app/Widget&quot;: &quot;app/Widget_NEW&quot;
   }
}</textarea></div><p>In this example, the request for <code class="docutils literal"><span class="pre">app/Widget</span></code> would load <code class="docutils literal"><span class="pre">app/Widget_NEW</span></code> from within <code class="docutils literal"><span class="pre">app/ModuleA</span></code> only.
Requests made for <code class="docutils literal"><span class="pre">app/Widget</span></code> from within any other module would continue to load <code class="docutils literal"><span class="pre">app/Widget</span></code>. This allows for
more complex loading scenarios in which you might have multiple concurrent versions of the same module that you need to
use in different parts of your application.</p>
<p>If you want to add a mapping that applies to all modules, you just use &#8220;*&#8221; for the module value like this:</p>
<div class="highlight"><pre><span class="nx">map</span><span class="o">:</span> <span class="p">{</span>
  <span class="s2">&quot;*&quot;</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">&quot;app/Widget&quot;</span><span class="o">:</span> <span class="s2">&quot;app/WidgetB&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">map: {
  &quot;*&quot;: {
    &quot;app/Widget&quot;: &quot;app/WidgetB&quot;
  }
}</textarea></div><p>In this example all requests for <code class="docutils literal"><span class="pre">app/Widget</span></code> would load <code class="docutils literal"><span class="pre">app/WidgetB</span></code> regardless of which module the request
originated from. The &#8220;*&#8221; option can be used in conjunction with other mappings remembering that the most specific
mappings take precedence.</p>
<p>In most cases, the <code class="docutils literal"><span class="pre">map</span></code> option in combination with <code class="docutils literal"><span class="pre">packages</span></code> is a better solution than <code class="docutils literal"><span class="pre">alias</span></code> because of its
flexibility. For more information on the <code class="docutils literal"><span class="pre">map</span></code> option, including it&#8217;s partial matching capabilities, you can check
out <a class="reference external" href="http://www.sitepen.com/blog/2013/07/03/dojo-faq-what-is-the-map-config-option/">this SitePen blog post</a>.</p>
</div>
<div class="section" id="normalizing-module-identifiers">
<h2><a class="toc-backref" href="#id10">Normalizing Module Identifiers</a><a class="headerlink" href="#normalizing-module-identifiers" title="Permalink to this headline">¶</a></h2>
<p>The following steps outline the loader&#8217;s internal normalization process.  This process involves a module ID
(<code class="docutils literal"><span class="pre">moduleId</span></code>) and, in the case of context-sensitive require, a reference module (<code class="docutils literal"><span class="pre">referenceModule</span></code>), and yields a
resulting path or URL (<code class="docutils literal"><span class="pre">result</span></code>).</p>
<blockquote>
<div><p>1. If <code class="docutils literal"><span class="pre">moduleId</span></code> begins with a protocol (for example, &#8220;http:&#8221;) or a forward-slash, or ends with a &#8221;.js&#8221; suffix,
assume the request is for an arbitrary chunk of JavaScript, not a module.  In this case the rest of these steps are
effectively skipped.</p>
<p>2. If <code class="docutils literal"><span class="pre">moduleId</span></code> is relative (i.e. its first character is &#8221;.&#8221;) and no <code class="docutils literal"><span class="pre">referenceModule</span></code> is given, throw an Error:
<code class="docutils literal"><span class="pre">moduleId</span></code> is not resolvable.</p>
<p>3. If <code class="docutils literal"><span class="pre">moduleId</span></code> is relative and <code class="docutils literal"><span class="pre">referenceModule</span></code> is given, set <code class="docutils literal"><span class="pre">moduleId</span></code> to the module identifier given by
<code class="docutils literal"><span class="pre">referenceModule</span> <span class="pre">+</span> <span class="pre">&quot;/../&quot;</span> <span class="pre">+</span> <span class="pre">moduleId</span></code> and collapse any relative segments. At this point, <code class="docutils literal"><span class="pre">moduleId</span></code> should contain
no relative fragments; if it does, throw an Error: <code class="docutils literal"><span class="pre">moduleId</span></code> is not resolvable.</p>
<p>4. If <code class="docutils literal"><span class="pre">referenceModule</span></code> is given, and it is a member of a package defined in the <code class="docutils literal"><span class="pre">packages</span></code> configuration
variable, and that package also has an entry in the <code class="docutils literal"><span class="pre">packageMap</span></code> configuration variable, replace the leftmost
segment of <code class="docutils literal"><span class="pre">moduleId</span></code> (the package name) with the value given in <code class="docutils literal"><span class="pre">packageMap</span></code>.</p>
<p>5. Look up the <code class="docutils literal"><span class="pre">moduleId</span></code> computed in Step 3 in the <code class="docutils literal"><span class="pre">aliases</span></code> configuration variable. If <code class="docutils literal"><span class="pre">moduleId</span></code> is aliased,
restart the process at Step 3 with the new <code class="docutils literal"><span class="pre">moduleId</span></code> from <code class="docutils literal"><span class="pre">aliases</span></code>.  Note that this means <code class="docutils literal"><span class="pre">aliases</span></code> is
referenced <em>after</em> <code class="docutils literal"><span class="pre">packageMap</span></code> has taken effect.</p>
<p>6. If the <code class="docutils literal"><span class="pre">moduleId</span></code> is only one segment long, and this segment is identical to a package name in the <code class="docutils literal"><span class="pre">packages</span></code>
configuration variable, append &#8220;/&#8221; and the value of the <code class="docutils literal"><span class="pre">main</span></code> configuration variable for the package to
<code class="docutils literal"><span class="pre">moduleId</span></code>. (For example, &#8220;dojo&#8221; would be resolved to &#8220;dojo/main&#8221;.)</p>
<p>At this point, <code class="docutils literal"><span class="pre">moduleId</span></code> has been fully normalized to an absolute module identifier known to the loader (that is, the
reference module has no further influence on the absolute module identifier).</p>
<p>7. Find the longest module identifier fragment in <code class="docutils literal"><span class="pre">paths</span></code> that matches from the start of <code class="docutils literal"><span class="pre">moduleId</span></code>. If a match is
found, let <code class="docutils literal"><span class="pre">result</span></code> be equal to <code class="docutils literal"><span class="pre">moduleId</span></code> with the matched section replaced with the corresponding value from
<code class="docutils literal"><span class="pre">paths</span></code>.</p>
<p>8. If no matching paths were found in Step 7 and <code class="docutils literal"><span class="pre">moduleId</span></code> references a module in a package, let <code class="docutils literal"><span class="pre">result</span></code> be
equal to <code class="docutils literal"><span class="pre">moduleId</span></code> with its first segment (the package name) replaced with the <code class="docutils literal"><span class="pre">location</span></code> property from the
relevant package.</p>
<p>9. If neither Step 7 nor 8 were applied and has(&#8220;config-tlmSiblingOfDojo&#8221;) is truthy, then let <code class="docutils literal"><span class="pre">result</span></code> be equal to
<code class="docutils literal"><span class="pre">&quot;../&quot;</span> <span class="pre">+</span> <span class="pre">moduleId</span></code>.</p>
<ol class="arabic simple" start="10">
<li>If <code class="docutils literal"><span class="pre">result</span></code> is not absolute, prefix it with the value of the configuration variable <code class="docutils literal"><span class="pre">baseUrl</span></code>.</li>
<li>Append the suffix &#8221;.js&#8221; to <code class="docutils literal"><span class="pre">result</span></code>.</li>
</ol>
</div></blockquote>
<div class="section" id="normalization-examples">
<h3>Normalization Examples<a class="headerlink" href="#normalization-examples" title="Permalink to this headline">¶</a></h3>
<p>In these examples, assume that the default configuration is in use.</p>
<p>dojo</p>
<div class="highlight-python"><div class="highlight"><pre>dojo ⇒ dojo/main (Step 6)
dojo/main ⇒ ./main (Step 8)
./main ⇒ path/to/dojo/ + ./main ⇒ path/to/dojo/main (Step 10)
path/to/dojo/main.js (Step 11)
</pre></div>
</div>
<p>dojo/store/api/Store</p>
<div class="highlight-python"><div class="highlight"><pre>dojo/store/api/Store ⇒ ./store/api/Store (Step 8)
./store/api/Store ⇒ path/to/dojo/ + ./store/api/Store ⇒ path/to/dojo/store/api/Store (Step 10)
path/to/dojo/store/api/Store.js (Step 11)
</pre></div>
</div>
<p>../../_base/Deferred with reference module dojo/store/util/QueryResults</p>
<div class="highlight-python"><div class="highlight"><pre>../../_base/Deferred ⇒ dojo/store/util/QueryResults + /../ + ../../_base/Deferred ⇒
dojo/store/util/QueryResults/../../../_base/Deferred ⇒ dojo/_base/Deferred (Step 3)
dojo/_base/Deferred ⇒ ./_base/Deferred (Step 8)
./_base/Deferred ⇒ path/to/dojo/ + ./_base/Deferred ⇒ path/to/dojo/_base/Deferred (Step 10)
path/to/dojo/_base/Deferred.js (Step 11)
</pre></div>
</div>
<p>myApp</p>
<div class="highlight-python"><div class="highlight"><pre>myApp ⇒ ../myApp (Step 9)
../myApp ⇒ path/to/dtk + ../myApp ⇒ path/to/myApp (Step 10)
path/to/myApp.js (Step 11)
</pre></div>
</div>
<p>myApp/someSubmodule</p>
<div class="highlight-python"><div class="highlight"><pre>myApp/someSubmodule ⇒ ../myApp/someSubmodule (Step 9)
../myApp/someSubmodule ⇒ path/to + ../myApp/someSubmodule ⇒ path/to/myApp/someSubmodule (Step 10)
path/to/myApp/someSubmodule.js (Step 11)
</pre></div>
</div>
<p>Notice how, assuming baseUrl points to the dojo tree as per the default, the top-level module identifier &quot;myApp&quot; is now a sibling of the dojo tree - just like <code class="docutils literal"><span class="pre">tlmSiblingOfDojo</span></code> suggests. This is how the dojo v1.x line has always treated top-level modules (absent a paths mapping).</p>
<p>If the myApp tree were to reside at &quot;/other/path/to/myApp&quot;, this could be achieved by providing a paths configuration like this:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">dojoConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">paths</span><span class="o">:</span><span class="p">{</span>
    <span class="s2">&quot;myApp&quot;</span><span class="o">:</span><span class="s2">&quot;/other/path/to/myApp&quot;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">var dojoConfig = {
  paths:{
    &quot;myApp&quot;:&quot;/other/path/to/myApp&quot;
  }
};</textarea></div><p>Since &quot;/other/path/to/my/App&quot; is absolute, Step 10 does not add baseUrl to the mix:</p>
<p>myApp</p>
<div class="highlight-python"><div class="highlight"><pre>myApp ⇒ /other/path/to/myApp (Step 7)
/other/path/to/myApp.js (Step 11)
</pre></div>
</div>
<p>myApp/someSubmodule</p>
<div class="highlight-python"><div class="highlight"><pre>myApp/someSubmodule ⇒ /other/path/to/myApp/someSubmodule (Step 7)
/other/path/to/myApp/someSubmodule.js (Step 11)
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">paths</span></code> can also map <em>to</em> path segments that are relative. For example, assume you have the following tree of modules:</p>
<div class="highlight-python"><div class="highlight"><pre>scripts/
  dtk/
    dojo/
    dijit/
    dojox/
  myApp/
  experimental/
</pre></div>
</div>
<p>In this case, myApp is not a sibling of dojo, but is still reachable from the automatically-computed baseUrl that points to script/dtk/dojo. A paths entry that gives the path for myApp relative to baseUrl will work:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">dojoConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">paths</span><span class="o">:</span><span class="p">{</span>
    <span class="s2">&quot;myApp&quot;</span><span class="o">:</span><span class="s2">&quot;../../myApp&quot;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">var dojoConfig = {
  paths:{
    &quot;myApp&quot;:&quot;../../myApp&quot;
  }
};</textarea></div><p>Resulting in...</p>
<p>myApp</p>
<div class="highlight-python"><div class="highlight"><pre>myApp ⇒ ../../myApp (Step 7)
../../myApp ⇒ path/to/dtk/dojo/ + ../../myApp ⇒ path/to/myApp (Step 10)
path/to/myApp ⇒ path/to/myApp.js (Step 11)
</pre></div>
</div>
<p>myApp/someSubmodule</p>
<div class="highlight-python"><div class="highlight"><pre>myApp ⇒ ../../myApp/someSubmodule (Step 7)
../../myApp/someSubmodule ⇒ path/to/dtk/dojo/ + ../../myApp ⇒ path/to/myApp/someSubmodule (Step 10)
path/to/myApp/someSubmodule ⇒ path/to/myApp/someSubmodule.js (Step 11)
</pre></div>
</div>
<p>This is one way to override the behavior of <code class="docutils literal"><span class="pre">tlmSiblingOfDojo</span></code>. Another way is to set <code class="docutils literal"><span class="pre">tlmSiblingOfDojo</span></code> to falsy or explicitly set <code class="docutils literal"><span class="pre">baseUrl</span></code>. Assuming the same tree of modules given above, consider this configuration:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">dojoConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">baseUrl</span><span class="o">:</span><span class="s2">&quot;scripts&quot;</span><span class="p">,</span>
  <span class="nx">packages</span><span class="o">:</span><span class="p">[{</span>
    <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;dojo&#39;</span><span class="p">,</span>
    <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;dtk/dojo&#39;</span>
  <span class="p">},{</span>
    <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;dijit&#39;</span><span class="p">,</span>
    <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;dtk/dijit&#39;</span>
  <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">var dojoConfig = {
  baseUrl:&quot;scripts&quot;,
  packages:[{
    name:'dojo',
    location:'dtk/dojo'
  },{
    name:'dijit',
    location:'dtk/dijit'
  }]
}</textarea></div><p>Notice that this time there is no paths mapping; we don't need one, because setting <code class="docutils literal"><span class="pre">baseUrl</span></code> sets <code class="docutils literal"><span class="pre">tlmSiblingOfDojo</span></code> to false, which means identifiers are now simply relative to <code class="docutils literal"><span class="pre">baseUrl</span></code>:</p>
<p>myApp</p>
<div class="highlight-python"><div class="highlight"><pre>myApp ⇒ scripts/ + myApp ⇒ script/myApp (Step 10)
scripts/myApp ⇒ scripts/myApp.js (Step 11)
</pre></div>
</div>
<p>myApp/someSubmodule</p>
<div class="highlight-python"><div class="highlight"><pre>myApp ⇒ scripts/ + myApp/someSubmodule ⇒ script/myApp/someSubmodule (Step 10)
scripts/myApp/someSubmodule ⇒ scripts/myApp/someSubmodule.js (Step 11)
</pre></div>
</div>
<p>dojo</p>
<div class="highlight-python"><div class="highlight"><pre>dojo ⇒ dojo/main (Step 4)
dojo/main ⇒ dtk/dojo/main (Step 8)
dtk/dojo/main ⇒ scripts/dtk/dojo/ + ./main ⇒ scripts/dtk/dojo/main (Step 10)
scripts/dtk/dojo/main.js (Step 11)
</pre></div>
</div>
<p>dojo/behavior</p>
<div class="highlight-python"><div class="highlight"><pre>dojo/behavior ⇒ dtk/dojo/behavior (Step 8)
dtk/dojo/behavior ⇒ scripts/dtk/dojo/ + ./behavior ⇒ scripts/dtk/dojo/behavior (Step 10)
scripts/dojo/behavior.js (Step 11)
</pre></div>
</div>
<p>If we make myApp a proper package, the resolution of &quot;myApp&quot; will change:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">dojoConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">baseUrl</span><span class="o">:</span><span class="s2">&quot;scripts&quot;</span>
  <span class="nx">packages</span><span class="o">:</span><span class="p">[{</span>
    <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;myApp&#39;</span><span class="p">,</span>
    <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;myApp&#39;</span>
  <span class="p">},{</span>
    <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;dijit&#39;</span><span class="p">,</span>
    <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;dtk/dijit&#39;</span>
  <span class="p">},{</span>
    <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;dijit&#39;</span><span class="p">,</span>
    <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;dtk/dijit&#39;</span>
  <span class="p">}]</span>
<span class="p">};</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">var dojoConfig = {
  baseUrl:&quot;scripts&quot;
  packages:[{
    name:'myApp',
    location:'myApp'
  },{
    name:'dijit',
    location:'dtk/dijit'
  },{
    name:'dijit',
    location:'dtk/dijit'
  }]
};</textarea></div><p>&quot;myApp/someSubmodule&quot; maps the same, but &quot;myApp&quot; does not:</p>
<p>myApp</p>
<div class="highlight-python"><div class="highlight"><pre>myApp ⇒ myApp/main (Step 4)
myApp/main ⇒ myApp/main (Step 8)
myApp/main ⇒ scripts/ + myApp/main ⇒ scripts/myApp/main (Step 10)
scripts/myApp/main.js (Step 11)
</pre></div>
</div>
<p>Configuring packages is usually a much better idea than cluttering the scripts directory with a bunch of top-level
modules.</p>
<p>Usually, you can map a module identifier anywhere. For example, maybe you are experimenting with a new module that
replaces dojo/cookie. In this case, you want all dojo modules to map as usual, but you want dojo/cookie to map to
scripts/experimental/dojo/cookie. All that's needed to achieve this is add an entry into paths:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">dojoConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">paths</span><span class="o">:</span><span class="p">{</span>
    <span class="s2">&quot;dojo/cookie&quot;</span><span class="o">:</span><span class="s2">&quot;../../experimental/dojo/cookie&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">var dojoConfig = {
  paths:{
    &quot;dojo/cookie&quot;:&quot;../../experimental/dojo/cookie&quot;
  }
}</textarea></div><p>Now, Step 7 will treat dojo/cookie differently than any other module identifier and map it to
scripts/experimental/dojo/cookie.</p>
<p>Finally, consider what happens when the module identifier you want to map is the parent segment of a tree of
modules. For example, consider this tree:</p>
<div class="highlight-python"><div class="highlight"><pre>scripts/
  myApp/
    myApi.js
    myApi/
      helper1.js
      helper2.js
</pre></div>
</div>
<p>On one hand, &quot;myApp/myApi&quot; is a module, but it's also a parent segment for the module identifiers &quot;myApp/myApi/helper1&quot;
and &quot;myApp/myApi/helper2&quot;. This means that the paths entry <code class="docutils literal"><span class="pre">&quot;myApp/myApi&quot;:&quot;path/to/another/myApi&quot;</span></code> will remap the two
helper modules as well. More often than not, this is exactly what you'll want, but if it isn't, you can simply add more
path entries for the original helpers. Here's what that would look like:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">dojoConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">paths</span><span class="o">:</span><span class="p">{</span>
    <span class="s2">&quot;myApp/myApi&quot;</span><span class="o">:</span><span class="s2">&quot;path/to/another/myApi&quot;</span><span class="p">,</span>
    <span class="s2">&quot;myApp/myApi/helper1&quot;</span><span class="o">:</span><span class="s2">&quot;path/to/original/myApi/helper1&quot;</span><span class="p">,</span>
    <span class="s2">&quot;myApp/myApi/helper2&quot;</span><span class="o">:</span><span class="s2">&quot;path/to/original/myApi/helper2&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">var dojoConfig = {
  paths:{
    &quot;myApp/myApi&quot;:&quot;path/to/another/myApi&quot;,
    &quot;myApp/myApi/helper1&quot;:&quot;path/to/original/myApi/helper1&quot;,
    &quot;myApp/myApi/helper2&quot;:&quot;path/to/original/myApi/helper2&quot;
  }
}</textarea></div><p>That's pretty verbose and not very convenient, but this is also a highly unusual configuration that you'll rarely, if
ever, need.</p>
</div>
</div>
<div class="section" id="relocating-module-namespaces">
<span id="loader-amd-relocating-module-namespaces"></span><h2><a class="toc-backref" href="#id11">Relocating Module Namespaces</a><a class="headerlink" href="#relocating-module-namespaces" title="Permalink to this headline">¶</a></h2>
<p>If you want to use two packages with the same name at the same time, as long as the package authors followed best
practices and did not use an explicit <code class="docutils literal"><span class="pre">moduleId</span></code> in their <code class="docutils literal"><span class="pre">define</span></code> calls, you can simply install the two packages to
two different directories and then define each package with a unique name in the <code class="docutils literal"><span class="pre">packages</span></code> array. For example:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">dojoConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">baseUrl</span><span class="o">:</span> <span class="s2">&quot;./&quot;</span><span class="p">,</span>
  <span class="nx">packages</span><span class="o">:</span> <span class="p">[{</span>
      <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;util1&quot;</span><span class="p">,</span>
      <span class="nx">location</span><span class="o">:</span> <span class="s2">&quot;packages/util1&quot;</span>
    <span class="p">},</span> <span class="p">{</span>
      <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;util2&quot;</span><span class="p">,</span>
      <span class="nx">location</span><span class="o">:</span> <span class="s2">&quot;packages/util2&quot;</span>
    <span class="p">}]</span>
<span class="p">};</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">var dojoConfig = {
  baseUrl: &quot;./&quot;,
  packages: [{
      name: &quot;util1&quot;,
      location: &quot;packages/util1&quot;
    }, {
      name: &quot;util2&quot;,
      location: &quot;packages/util2&quot;
    }]
};</textarea></div><p>You can then access these packages normally through <code class="docutils literal"><span class="pre">require</span></code> or <code class="docutils literal"><span class="pre">define</span></code>:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s2">&quot;util1&quot;</span><span class="p">,</span> <span class="s2">&quot;util2&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">util1</span><span class="p">,</span> <span class="nx">util2</span><span class="p">){</span>
  <span class="c1">// well that was easy.</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">define([&quot;util1&quot;, &quot;util2&quot;], function(util1, util2){
  // well that was easy.
});</textarea></div><p>It is also possible to remap packages that are required by another package. For example:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">dojoConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">packages</span><span class="o">:</span> <span class="p">[{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;util1&quot;</span><span class="p">,</span>
    <span class="nx">location</span><span class="o">:</span> <span class="s2">&quot;packages/util1&quot;</span><span class="p">,</span>
    <span class="nx">packageMap</span><span class="o">:</span> <span class="p">{</span><span class="nx">dojox</span><span class="o">:</span><span class="s2">&quot;dojox1&quot;</span><span class="p">}</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;util2&quot;</span><span class="p">,</span>
    <span class="nx">location</span><span class="o">:</span> <span class="s2">&quot;packages/util2&quot;</span><span class="p">,</span>
    <span class="nx">packageMap</span><span class="o">:</span> <span class="p">{</span><span class="nx">dojox</span><span class="o">:</span><span class="s2">&quot;dojox2&quot;</span><span class="p">}</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;dojox1&quot;</span><span class="p">,</span>
    <span class="nx">location</span><span class="o">:</span> <span class="s2">&quot;packages/dojox-version-1-6&quot;</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;dojox2&quot;</span><span class="p">,</span>
    <span class="nx">location</span><span class="o">:</span> <span class="s2">&quot;packages/dojox-version-1-4&quot;</span>
  <span class="p">}]</span>
<span class="p">};</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">var dojoConfig = {
  packages: [{
    name: &quot;util1&quot;,
    location: &quot;packages/util1&quot;,
    packageMap: {dojox:&quot;dojox1&quot;}
  }, {
    name: &quot;util2&quot;,
    location: &quot;packages/util2&quot;,
    packageMap: {dojox:&quot;dojox2&quot;}
  }, {
    name: &quot;dojox1&quot;,
    location: &quot;packages/dojox-version-1-6&quot;
  }, {
    name: &quot;dojox2&quot;,
    location: &quot;packages/dojox-version-1-4&quot;
  }]
};</textarea></div><p>This code will ensure that all explicit references to the &quot;dojox&quot; package in &quot;util1&quot; are redirected to &quot;dojox1&quot;, and all
references to the &quot;dojox&quot; package in &quot;util2&quot; are redirected to &quot;dojox2&quot;.</p>
<p>This design replaces the so-called &quot;multi-version&quot; design in dojo v1.6- and eliminates the need for contexts as
implemented in RequireJS. Notice that, unlike the multi-version design, no build is required to deploy a relocated
package. It's all a matter of simple configuration. This is a very powerful feature and only dojo has it.</p>
</div>
<div class="section" id="utility-functions">
<span id="loader-amd-utility-functions"></span><h2><a class="toc-backref" href="#id12">Utility Functions</a><a class="headerlink" href="#utility-functions" title="Permalink to this headline">¶</a></h2>
<p>Dojo's AMD API includes a few utility functions:</p>
<p><code class="docutils literal"><span class="pre">require.toUrl</span></code> converts a name that is prefixed by a module identifier to a URL by replacing the module identifier
prefix with the path resolved by the normalization process.</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">.</span><span class="nx">toUrl</span><span class="p">(</span>
  <span class="nx">id</span> <span class="c1">// (string) a resource identifier that is prefixed by a module identifier</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">string</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require.toUrl(
  id // (string) a resource identifier that is prefixed by a module identifier
) -&gt; string</textarea></div><p>For example, let's say you've defined a configuration that will cause the module identifier &quot;myApp/widgets/button&quot; to
point to the resource <code class="docutils literal"><span class="pre">http://acmeCopy.com/myApp/widgets/button.js</span></code>. In such a case,
<code class="docutils literal"><span class="pre">require.toUrl(&quot;myApp/widgets/templates/button.html&quot;)</span></code> would return
<code class="docutils literal"><span class="pre">http://acmeCopy.com/myApp/widgets/templates/button.html</span></code>.</p>
<p>This also works with relative IDs when <code class="docutils literal"><span class="pre">require</span></code> is a <a class="reference internal" href="#context-sensitive-require">context-sensitive require</a>.
For example:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s2">&quot;require&quot;</span><span class="p">,</span> <span class="p">...],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="p">...){</span>
     <span class="p">...</span> <span class="nx">require</span><span class="p">.</span><span class="nx">toUrl</span><span class="p">(</span><span class="s2">&quot;./images/foo.jpg&quot;</span><span class="p">)</span> <span class="p">...</span>
<span class="p">}</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">define([&quot;require&quot;, ...], function(require, ...){
     ... require.toUrl(&quot;./images/foo.jpg&quot;) ...
}</textarea></div><p>Note how the URL begins with &quot;./&quot;.</p>
<p><code class="docutils literal"><span class="pre">require.toAbsMid</span></code> converts the given module ID to an absolute module ID. This function is only useful when used in
conjunction with a <a class="reference internal" href="#context-sensitive-require">context-sensitive require</a>.</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">.</span><span class="nx">toAbsMid</span><span class="p">(</span>
  <span class="nx">moduleId</span> <span class="c1">// (string) a module identifier</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">string</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require.toAbsMid(
  moduleId // (string) a module identifier
) -&gt; string</textarea></div><p><code class="docutils literal"><span class="pre">require.undef</span></code> removes a module from the module namespace. <code class="docutils literal"><span class="pre">require.undef</span></code> is primarily useful for test frameworks that need to load and unload modules without having to reload the entire application.</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">.</span><span class="nx">undef</span><span class="p">(</span>
  <span class="nx">moduleId</span> <span class="c1">// (string) a module identifier</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">undefined</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require.undef(
  moduleId // (string) a module identifier
) -&gt; undefined</textarea></div><p><code class="docutils literal"><span class="pre">require.log</span></code> is an alias to the current environment's <code class="docutils literal"><span class="pre">console.log</span></code> equivalent. Each passed argument is logged to a separate line.</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
  <span class="c1">// (...rest) one or more messages to log</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">undefined</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require.log(
  // (...rest) one or more messages to log
) -&gt; undefined</textarea></div><p><code class="docutils literal"><span class="pre">require.toAbsMid</span></code> and <code class="docutils literal"><span class="pre">require.undef</span></code> are Dojo-specific extensions to the AMD specification.</p>
</div>
<div class="section" id="commonjs-require-exports-and-module">
<h2><a class="toc-backref" href="#id13">CommonJS require, exports, and module</a><a class="headerlink" href="#commonjs-require-exports-and-module" title="Permalink to this headline">¶</a></h2>
<p>The AMD specification defines three special module identifiers: <code class="docutils literal"><span class="pre">require</span></code>, <code class="docutils literal"><span class="pre">exports</span></code>, and <code class="docutils literal"><span class="pre">module</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">require</span></code> module works as described in <a class="reference internal" href="#context-sensitive-require">Context-sensitive require</a>.</p>
<p>The <code class="docutils literal"><span class="pre">module</span></code> module returns an object that contains the following properties:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">id</span></code>: a unique module identifier string that, when passed to <code class="docutils literal"><span class="pre">require</span></code>, returns the module's value</li>
<li><code class="docutils literal"><span class="pre">uri</span></code>: the fully-qualified URI from which the module resource was loaded (this may not always be available)</li>
<li><code class="docutils literal"><span class="pre">exports</span></code>: described below</li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal"><span class="pre">exports</span></code> module and <code class="docutils literal"><span class="pre">module.exports</span></code> provide an alternative method for defining a module value. Instead of returning the value explicitly by a return statement in the factory function, <code class="docutils literal"><span class="pre">exports</span></code> provides a JavaScript object onto which properties can be attached. For example, the following two module definitions are identical:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">([],</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">someProperty</span><span class="o">:</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span>
    <span class="nx">someOtherProperty</span><span class="o">:</span><span class="s2">&quot;world&quot;</span>
  <span class="p">};</span>
<span class="p">});</span>


<span class="nx">define</span><span class="p">([</span><span class="s2">&quot;exports&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">exports</span><span class="p">){</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">someProperty</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">someOtherProperty</span> <span class="o">=</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">define([], function(){
  return {
    someProperty:&quot;hello&quot;,
    someOtherProperty:&quot;world&quot;
  };
});


define([&quot;exports&quot;], function(exports){
  exports.someProperty = &quot;hello&quot;;
  exports.someOtherProperty = &quot;world&quot;;
});</textarea></div><p>Attaching properties to the <code class="docutils literal"><span class="pre">exports</span></code> object is the only way to ensure modules are properly defined when they are in a circular dependency.</p>
<p>The <code class="docutils literal"><span class="pre">module.exports</span></code> object can also be replaced entirely if desired:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s2">&quot;module&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">module</span><span class="p">){</span>
  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">dojo</span><span class="p">.</span><span class="nx">declare</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">define([&quot;module&quot;], function(module){
  module.exports = dojo.declare(/*...*/);
});</textarea></div><p>Finally, the AMD specification states that when <code class="docutils literal"><span class="pre">define</span></code> is provided only a factory function, the loader must act as though a dependencies array was passed with the value <code class="docutils literal"><span class="pre">[&quot;require&quot;,</span> <span class="pre">&quot;exports&quot;,</span> <span class="pre">&quot;module&quot;]</span></code>. In other words, the following two <code class="docutils literal"><span class="pre">define</span></code> calls are equivalent:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s2">&quot;require&quot;</span><span class="p">,</span> <span class="s2">&quot;exports&quot;</span><span class="p">,</span> <span class="s2">&quot;module&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">){</span>
  <span class="c1">// define a module</span>
<span class="p">});</span>

<span class="nx">define</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">){</span>
  <span class="c1">// define a module</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">define([&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;], function(require, exports, module){
  // define a module
});

define(function(require, exports, module){
  // define a module
});</textarea></div><p>In the latter case, calls within the function of the form <code class="docutils literal"><span class="pre">require(&quot;foo&quot;)</span></code> will be scanned for and resolved as though they were given as dependencies.</p>
<p>All of this functionality is provided primarily for compatibility with other CommonJS modules. You should <strong>not</strong> use it unless you are writing modules specifically for e.g. node.js and do not want to require users to load a fully-compliant AMD loader, or in the case of <code class="docutils literal"><span class="pre">exports</span></code>, if you need to resolve a circular dependency.</p>
</div>
<div class="section" id="plugins">
<h2><a class="toc-backref" href="#id14">Plugins</a><a class="headerlink" href="#plugins" title="Permalink to this headline">¶</a></h2>
<p>Plugins can be used to extend the loader to support loading resources other than AMD modules (for example, templates or i18n bundles). Dojo v1.7 includes several plugins of its own:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="../dojo/domReady.html#dojo-domready"><span>dojo/domReady</span></a>: defers execution of the module's factory function until the DOM is ready.</li>
<li><a class="reference internal" href="../dojo/text.html#dojo-text"><span>dojo/text</span></a>: loads text resources; it is a superset of RequireJS's text plugin, and subsumes <code class="docutils literal"><span class="pre">dojo.cache</span></code>.</li>
<li><a class="reference internal" href="../dojo/i18n.html#dojo-i18n"><span>dojo/i18n</span></a>: loads i18n bundles either in legacy or AMD format. It includes the v1.6- i18n API and is a superset of
RequireJS's i18n plugin.</li>
<li><a class="reference internal" href="../dojo/has.html#dojo-has"><span>dojo/has</span></a>: allows has.js expressions to be used to conditionally load modules.</li>
<li><a class="reference internal" href="../dojo/require.html#dojo-require"><span>dojo/require</span></a>: downloads a legacy module without loading it. This allows the legacy code path to be guaranteed.</li>
<li><cite>dojo/loadInit</cite>: causes dojo.loadInit callbacks then other legacy API functions to be executed--in particular
dojo.require[After]If--that are associated with a module</li>
</ul>
</div></blockquote>
<p>When a module identifier passed to <code class="docutils literal"><span class="pre">require</span></code> or <code class="docutils literal"><span class="pre">define</span></code> contains an &quot;!&quot;, the loader splits the string in two at the
exclamation point. The string to the left of &quot;!&quot; is treated like a normal module ID and is used as the identifier for
the desired plugin; the string to the right of &quot;!&quot; is passed to the plugin for processing.</p>
<p>Like all other AMD modules, the plugin module is loaded only once; unlike normal modules, it must return an object
containing a function named &quot;load&quot; with this signature:</p>
<div class="highlight"><pre><span class="nx">load</span><span class="p">(</span>
  <span class="nx">id</span><span class="p">,</span>        <span class="c1">// the string to the right of the !</span>
  <span class="nx">require</span><span class="p">,</span>   <span class="c1">// AMD require; usually a context-sensitive require bound to the module making the plugin request</span>
  <span class="nx">callback</span>   <span class="c1">// the function the plugin should call with the return value once it is done</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">undefined</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">load(
  id,        // the string to the right of the !
  require,   // AMD require; usually a context-sensitive require bound to the module making the plugin request
  callback   // the function the plugin should call with the return value once it is done
) -&gt; undefined</textarea></div><p>Here is an example of loading some raw text with a &quot;text&quot; plugin:</p>
<div class="highlight"><pre><span class="c1">// this is &quot;myApp/myModule&quot;</span>
<span class="nx">define</span><span class="p">([</span><span class="s2">&quot;text!./templates/myModule.html&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">template</span><span class="p">){</span>
  <span class="c1">// template is a string loaded from the resource implied by myApp/templates/myModule.html</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">// this is &quot;myApp/myModule&quot;
define([&quot;text!./templates/myModule.html&quot;], function(template){
  // template is a string loaded from the resource implied by myApp/templates/myModule.html
});</textarea></div><p>And a simple &quot;text&quot; plugin implementation:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s2">&quot;dojo/_base/xhr&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">xhr</span><span class="p">){</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">load</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">require</span><span class="p">,</span> <span class="nx">callback</span><span class="p">){</span>
      <span class="nx">xhr</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span>
        <span class="nx">url</span><span class="o">:</span> <span class="nx">require</span><span class="p">.</span><span class="nx">toUrl</span><span class="p">(</span><span class="nx">id</span><span class="p">),</span>
        <span class="nx">load</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">){</span>
          <span class="nx">callback</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">define([&quot;dojo/_base/xhr&quot;], function(xhr){
  return {
    load: function(id, require, callback){
      xhr.get({
        url: require.toUrl(id),
        load: function(text){
          callback(text);
        }
      });
    }
  };
});</textarea></div><p>Unlike the value returned by regular modules, the loader does not cache the value passed by a plugin to <code class="docutils literal"><span class="pre">callback</span></code>. A plugin can maintain its own internal cache, if desired:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s2">&quot;dojo&quot;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">dojo</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">cache</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">load</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">require</span><span class="p">,</span> <span class="nx">callback</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nx">require</span><span class="p">.</span><span class="nx">toUrl</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">url</span> <span class="k">in</span> <span class="nx">cache</span><span class="p">){</span>
        <span class="nx">callback</span><span class="p">(</span><span class="nx">cache</span><span class="p">[</span><span class="nx">url</span><span class="p">]);</span>
      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="nx">dojo</span><span class="p">.</span><span class="nx">xhrGet</span><span class="p">({</span>
          <span class="nx">url</span><span class="o">:</span> <span class="nx">url</span><span class="p">,</span>
          <span class="nx">load</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">){</span>
            <span class="nx">callback</span><span class="p">(</span><span class="nx">cache</span><span class="p">[</span><span class="nx">url</span><span class="p">]</span> <span class="o">=</span> <span class="nx">text</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">});</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">define([&quot;dojo&quot;], function(dojo){
  var cache = {};
  return {
    load: function(id, require, callback){
      var url = require.toUrl(id);
      if(url in cache){
        callback(cache[url]);
      }else{
        dojo.xhrGet({
          url: url,
          load: function(text){
            callback(cache[url] = text);
          }
        });
      }
    }
  };
});</textarea></div></div>
<div class="section" id="window-load-detection">
<h2><a class="toc-backref" href="#id15">Window Load Detection</a><a class="headerlink" href="#window-load-detection" title="Permalink to this headline">¶</a></h2>
<p>The Dojo loader connects to the <code class="docutils literal"><span class="pre">window.onload</span></code> event and sets <code class="docutils literal"><span class="pre">document.readyState</span></code> to &quot;complete&quot; if it's not
already set. This allows a normal AMD module to rely on <code class="docutils literal"><span class="pre">document.readyState</span></code>, even in browsers that do not properly
support this property.</p>
</div>
<div class="section" id="the-micro-event-api">
<h2><a class="toc-backref" href="#id16">The Micro Event API</a><a class="headerlink" href="#the-micro-event-api" title="Permalink to this headline">¶</a></h2>
<p>The loader defines a micro event API that it uses to report errors, configuration changes, tracing, and idle state. The
API consists of two functions:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">.</span><span class="nx">on</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span>
  <span class="nx">eventName</span><span class="p">,</span> <span class="c1">// (string) the event name to connect to</span>
  <span class="nx">listener</span>   <span class="c1">// (function) called upon event</span>
<span class="p">)</span>

<span class="nx">require</span><span class="p">.</span><span class="nx">signal</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span>
  <span class="nx">eventName</span><span class="p">,</span> <span class="c1">// (string) the event name to signal</span>
  <span class="nx">args</span>       <span class="c1">// (array) the arguments to apply to each listener</span>
<span class="p">)</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require.on = function(
  eventName, // (string) the event name to connect to
  listener   // (function) called upon event
)

require.signal = function(
  eventName, // (string) the event name to signal
  args       // (array) the arguments to apply to each listener
)</textarea></div><p>The loader itself uses <code class="docutils literal"><span class="pre">require.signal</span></code> to signal its own events. Clients may listen for loader events by passing a
listener function to <code class="docutils literal"><span class="pre">require.on</span></code>. For example, a client could connect to the &quot;config&quot; event to watch for
configuration changes like this:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">handle</span> <span class="o">=</span> <span class="nx">require</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">config</span><span class="p">,</span> <span class="nx">rawConfig</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">myApp</span><span class="p">.</span><span class="nx">myConfigVar</span><span class="p">){</span>
        <span class="c1">// do something</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">var handle = require.on(&quot;config&quot;, function(config, rawConfig){
      if(config.myApp.myConfigVar){
        // do something
  }
});</textarea></div><p>Notice that the &quot;config&quot; event provides both a <code class="docutils literal"><span class="pre">config</span></code> and a <code class="docutils literal"><span class="pre">rawConfig</span></code> argument; this is described in more detail
in the <a class="reference internal" href="#configuration">Configuration</a> section.</p>
<p><code class="docutils literal"><span class="pre">require.on</span></code> returns an opaque <code class="docutils literal"><span class="pre">handle</span></code> object that can be used to stop listening by calling <code class="docutils literal"><span class="pre">handle.remove()</span></code>.</p>
<p>The loader reserves the event names &quot;error&quot;, &quot;config&quot;, &quot;idle&quot;, and &quot;trace&quot;. Client applications that wish to use the
micro event API with custom events are free to use any other event names.</p>
</div>
<div class="section" id="error-reporting">
<h2><a class="toc-backref" href="#id17">Error Reporting</a><a class="headerlink" href="#error-reporting" title="Permalink to this headline">¶</a></h2>
<p>When things go wrong, the loader raises an &quot;error&quot; event through the micro event API. To monitor loader errors, simply connect via <code class="docutils literal"><span class="pre">require.on</span></code> like this:</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">handleError</span><span class="p">(</span><span class="nx">error</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">.</span><span class="nx">src</span><span class="p">,</span> <span class="nx">error</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">require</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">,</span> <span class="nx">handleError</span><span class="p">);</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">function handleError(error){
  console.log(error.src, error.id);
}

require.on(&quot;error&quot;, handleError);</textarea></div><p>The first argument sent to the listener is a loader error object that contains the property <code class="docutils literal"><span class="pre">src</span></code>, which is currently always set to &quot;dojoLoader&quot;, and the property <code class="docutils literal"><span class="pre">id</span></code>, which gives a string identifier indicating the particular error. The loader defines the following error identifiers:</p>
<dl class="docutils">
<dt>factoryThrew</dt>
<dd>A module factory function threw an Error.</dd>
<dt>xhrFailed</dt>
<dd>An XHR failed to retrieve a module resource. Typically, this indicates an HTTP 404 error, and is often caused by a configuration problem with paths, aliases, packages, and/or baseUrl.</dd>
<dt>multipleDefine</dt>
<dd>AMD <code class="docutils literal"><span class="pre">define</span></code> was called referencing a module that has already been defined. The most common cause of this problem is loading modules via <code class="docutils literal"><span class="pre">&lt;script&gt;</span></code> elements in the HTML document. Use the loader; don't use <code class="docutils literal"><span class="pre">&lt;script&gt;</span></code> elements. The second most common cause is passing explicit module identifiers to <code class="docutils literal"><span class="pre">define</span></code>; don't do this either.</dd>
<dt>timeout</dt>
<dd><code class="docutils literal"><span class="pre">waitSeconds</span></code> has elapsed since the last module was requested, yet all modules have not arrived. Typically, this indicates an HTTP 404 error, and is often caused by a configuration problem with paths, aliases, packages, and/or baseUrl.</dd>
<dt>defineIe</dt>
<dd>An anonymous <code class="docutils literal"><span class="pre">define</span></code> call occurred in an Internet Explorer environment but it was impossible to determine the implied module identifier. defineIe errors are usually caused by the same kinds of problems that cause multipleDefine errors.</dd>
</dl>
<p>Loader errors are often impossible to recover from. If your application demands a module that does not exist, there's nothing the loader can do to fix that situation. However, this API can be used to attempt other strategies (like loading from a backup server) or to provide error messages to improve user experience.</p>
</div>
<div class="section" id="debugging">
<h2><a class="toc-backref" href="#id18">Debugging</a><a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h2>
<p>Debugging highly asynchronous processes like loading a tree of AMD modules can be tricky. Here are a few pointers to make this task manageable:</p>
<blockquote>
<div><ul class="simple">
<li>The most common error for programmers used to the legacy loader API is to express a module identifier using dots
instead of slashes.</li>
<li>A common syntax error that's not well reported in some browsers is to miss a comma in a dependencies argument.</li>
<li>A common programming error is to accidentally mismatch module identifiers in the dependencies array with their
corresponding parameters in the callback/factory function. This will often show up as &quot;object is not a constructor&quot;
or &quot;method does not exist&quot; or similar.</li>
<li>In some browsers, in some circumstances, inserting breakpoints will change the asynchronous flow and cause an
application to fail only when breakpoints are inserted. This generally indicates the program is depending on modules
being defined in a certain order; well-designed AMD applications will have no such requirement.</li>
</ul>
</div></blockquote>
<p>The Dojo loader also exposes its internal state for inspection during debugging on the <code class="docutils literal"><span class="pre">require</span></code> object. These are:</p>
<dl class="docutils">
<dt>async</dt>
<dd>A boolean indicating whether or not the asynchronous loader is in use.</dd>
<dt>legacyMode</dt>
<dd>A string describing the legacy mode of the loader (if async is false).</dd>
<dt>baseUrl</dt>
<dd>The baseUrl configuration variable</dd>
<dt>paths</dt>
<dd>The paths configuration variable</dd>
<dt>packs</dt>
<dd>The package configuration. This is a combination of all passed package configurations.</dd>
<dt>waiting</dt>
<dd>A list of modules the loader has requested that have not yet arrived. If the loader seems to stall, look here second; look in your debugger's network panel for 404 errors first.</dd>
<dt>execQ</dt>
<dd>The queue of modules that is scheduled to execute. If this queue seems stalled, then there is almost certainly another problem, probably 404 errors, syntax errors, or naming errors elsewhere.</dd>
<dt>modules</dt>
<dd><p class="first">The module namespace. Each entry holds all information about each module known to the loader:</p>
<ul class="last simple">
<li><code class="docutils literal"><span class="pre">result</span></code> holds the module value</li>
<li><code class="docutils literal"><span class="pre">injected</span></code> holds the loaded state (one of 0, &quot;requested&quot;, &quot;arrived&quot;)</li>
<li><code class="docutils literal"><span class="pre">executed</span></code> holds the executed state of a factory (one of 0, &quot;executing&quot;, &quot;executed&quot;)</li>
<li><code class="docutils literal"><span class="pre">pid</span></code> holds the owning package (if any)</li>
<li><code class="docutils literal"><span class="pre">url</span></code> holds the address the loader has computed for the resource that defines the module</li>
<li><code class="docutils literal"><span class="pre">def</span></code> holds the factory</li>
</ul>
</dd>
</dl>
<p>Warning: these internal definitions are exposed and discussed here to help with debugging <strong>only</strong>. Do <strong>not</strong> use them in your own code. These structures may change!</p>
</div>
<div class="section" id="tracing">
<h2><a class="toc-backref" href="#id19">Tracing</a><a class="headerlink" href="#tracing" title="Permalink to this headline">¶</a></h2>
<p>Owing to the asynchronous nature of the loader, sometimes the best technique to solve a loading problem is to let the loader proceed normally without any breakpoints and analyze the order of certain loader events like injecting, defining, or executing a module. The source version of the loader contains a tracing API to facilitate this debugging technique. The tracing API can also be used with your own code if desired.</p>
<p>The tracing API has the following signatures:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">.</span><span class="nx">trace</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span>
  <span class="nx">groupId</span><span class="p">,</span> <span class="c1">// (string) the tracing group identifier to which this trace message belongs</span>
  <span class="nx">args</span>     <span class="c1">// (array of any) additional data to send with trace</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">undefined</span>

<span class="nx">require</span><span class="p">.</span><span class="nx">trace</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span>
  <span class="nx">groupId</span><span class="p">,</span> <span class="c1">// (string) a tracing group identifier</span>
  <span class="nx">enable</span>   <span class="c1">// (boolean) enable or disable tracing of messages from groupId</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">undefined</span>

<span class="nx">require</span><span class="p">.</span><span class="nx">trace</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span>
  <span class="nx">groupMap</span>  <span class="c1">// (object:groupId --&gt; boolean) a map from trace group identifier to on/off value</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">undefined</span>

<span class="nx">require</span><span class="p">.</span><span class="nx">trace</span><span class="p">.</span><span class="nx">on</span> <span class="c1">// (boolean) enable/disable all tracing</span>

<span class="nx">require</span><span class="p">.</span><span class="nx">trace</span><span class="p">.</span><span class="nx">group</span> <span class="c1">// (object) a map from trace group id to boolean</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require.trace = function(
  groupId, // (string) the tracing group identifier to which this trace message belongs
  args     // (array of any) additional data to send with trace
) -&gt; undefined

require.trace.set(
  groupId, // (string) a tracing group identifier
  enable   // (boolean) enable or disable tracing of messages from groupId
) -&gt; undefined

require.trace.set(
  groupMap  // (object:groupId --&gt; boolean) a map from trace group identifier to on/off value
) -&gt; undefined

require.trace.on // (boolean) enable/disable all tracing

require.trace.group // (object) a map from trace group id to boolean</textarea></div><p>To emit trace messages, call <code class="docutils literal"><span class="pre">require.trace</span></code> with a groupId and an array of information to be sent as part of the trace.</p>
<p>When <code class="docutils literal"><span class="pre">require.trace(groupId,</span> <span class="pre">args)</span></code> is called, the following process takes place:</p>
<ol class="arabic simple">
<li>If <code class="docutils literal"><span class="pre">trace.on</span></code> is falsy, then do nothing and return.</li>
<li>If <code class="docutils literal"><span class="pre">trace.group[groupId]</span></code> is falsy, then do nothing and return.</li>
<li>Signal the trace event via <a class="reference internal" href="#the-micro-event-api">the micro event API</a> with the argument <code class="docutils literal"><span class="pre">[groupId,</span> <span class="pre">args]</span></code>.</li>
<li>Concatenate <code class="docutils literal"><span class="pre">groupId</span></code> and the string value of each item in args into a comma-separated list and apply <code class="docutils literal"><span class="pre">require.log</span></code> to the resulting string.</li>
<li>Apply <code class="docutils literal"><span class="pre">require.log</span></code> to each item in args.</li>
</ol>
<p>Tracing can be turned on or off for one or more trace groups by providing a configuration variable <code class="docutils literal"><span class="pre">trace</span></code>. For example:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">({</span>
  <span class="nx">trace</span><span class="o">:</span><span class="p">{</span>
    <span class="s2">&quot;loader-inject&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="c1">// turn the loader-inject group on</span>
    <span class="s2">&quot;loader-define&quot;</span><span class="o">:</span><span class="mi">0</span> <span class="c1">// turn the loader-define group off</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require({
  trace:{
    &quot;loader-inject&quot;:1, // turn the loader-inject group on
    &quot;loader-define&quot;:0 // turn the loader-define group off
  }
});</textarea></div><p>Alternatively, require.trace.set can be called directly; there are two forms:</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">.</span><span class="nx">trace</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span>
  <span class="s2">&quot;loader-inject&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="c1">// turn the loader-inject group on</span>
  <span class="s2">&quot;loader-define&quot;</span><span class="o">:</span><span class="mi">0</span> <span class="c1">// turn the loader-define group off</span>
<span class="p">});</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require.trace.set({
  &quot;loader-inject&quot;:1, // turn the loader-inject group on
  &quot;loader-define&quot;:0 // turn the loader-define group off
});</textarea></div><p>...or, equivalently...</p>
<div class="highlight"><pre><span class="nx">require</span><span class="p">.</span><span class="nx">trace</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&quot;loader-inject&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">require</span><span class="p">.</span><span class="nx">trace</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&quot;loader-define&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">require.trace.set(&quot;loader-inject&quot;, 1);
require.trace.set(&quot;loader-define&quot;, 0);</textarea></div><p>All tracing can be suspended by setting <code class="docutils literal"><span class="pre">require.trace.on</span></code> to false; setting <code class="docutils literal"><span class="pre">require.trace.on</span></code> to true only enables the groups that have been individually set to true as described above.</p>
<p>The loader defines the following trace groups:</p>
<dl class="docutils">
<dt>loader-inject</dt>
<dd>Emitted when a module is injected into the application. args[0] will be &quot;cache&quot; if the module was in the loader cache, &quot;xhr&quot; if the module was injected via an XHR transaction, and &quot;script&quot; if the module was script-injected. Args[1] is the module identifier; args[2] is the URL/filename; if args[0] is &quot;xhr&quot;, args[3] will be <code class="docutils literal"><span class="pre">true</span></code> if asynchronous XHR was used.</dd>
<dt>loader-define</dt>
<dd>Emitted when <code class="docutils literal"><span class="pre">define</span></code> is called. args[0] is the module identifier. args[1] is the dependencies array. Notice that args give the decoded values of these parameters, not the actual values at arguments[0] and arguments[1]. Often the loader does not actually process the define call until the script that contains the define call has been fully processed; processing of the define call is traced with by &quot;loader-define-module&quot; (see below).</dd>
<dt>loader-exec-module</dt>
<dd>Emitted when the loader attempts or fails to run a module's factory by first tracing the module's dependency tree and running all dependent module factories. Notice that success is not guaranteed: if a dependent module can not be resolved (perhaps it has not arrived yet), then the attempt is aborted and reattempted later. args[0] is &quot;exec&quot; on attempt, &quot;abort&quot; on failure; args[1] is the module identifier.</dd>
<dt>loader-run-factory</dt>
<dd>Emitted when the loader is about to call a module's factory function after all dependencies have been satisfied. args[0] is the module identifier.</dd>
<dt>loader-finish-exec</dt>
<dd>Emitted when the loader is executing final cleanup after having successfully run a module's factory. This includes passing all queued plugin requests to newly instantiated plugin modules and updating module values for legacy modules. Args[0] is the module identifier.</dd>
<dt>loader-define-module</dt>
<dd>Emitted when the loader is about to process a previous <code class="docutils literal"><span class="pre">define</span></code> call. See loader-define, above. args[0] is the module identifier.</dd>
<dt>loader-circular-dependency</dt>
<dd>Emitted when the loader detects a circular dependency, which may or may not indicate a programming error.</dd>
</dl>
</div>
<div class="section" id="non-browser-environments">
<h2><a class="toc-backref" href="#id20">Non-browser Environments</a><a class="headerlink" href="#non-browser-environments" title="Permalink to this headline">¶</a></h2>
<p>As of v1.7, the Dojo loader supports Rhino and node.js out of the box. Loading the Dojo loader from the command-line with node.js looks like this:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c">#!/bin/bash</span>
node dojo/dojo.js <span class="nv">load</span><span class="o">=</span>config <span class="nv">load</span><span class="o">=</span>main
</pre></div>
</div>
<p>And like this with Rhino:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c">#!/bin/bash</span>
java -jar util/shrinksafe/js.jar dojo/dojo.js <span class="nv">baseUrl</span><span class="o">=</span>file:///full/path/to/dojo/dojo <span class="nv">load</span><span class="o">=</span>config <span class="nv">load</span><span class="o">=</span>main
</pre></div>
</div>
</div>
<div class="section" id="the-legacy-api">
<h2><a class="toc-backref" href="#id21">The Legacy API</a><a class="headerlink" href="#the-legacy-api" title="Permalink to this headline">¶</a></h2>
<p>In order to maintain backwards compatibility with v1.6-, the v1.7 loader includes the complete synchronous loader API
(dojo.provide, dojo.require, dojo.requireLocalization, dojo.requireIf, dojo.requireAfterIf, dojo.platformRequire, and
dojo.loadInit), and should work exactly the same as earlier loaders, with one exception:</p>
<p>Owing to the way <code class="docutils literal"><span class="pre">dojo.eval</span></code> is defined in v1.6- and the way some browsers' <code class="docutils literal"><span class="pre">eval</span></code> functions work, sometimes a
module's code would be evaluated in the global scope and sometimes it would be evaluated in a function scope. Consider
the module text:</p>
<div class="highlight"><pre><span class="nx">dojo</span><span class="p">.</span><span class="nx">provide</span><span class="p">(</span><span class="s2">&quot;module.that.defines.a.global&quot;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">someVariable</span> <span class="o">=</span> <span class="nx">anAwesomeCalculation</span><span class="p">();</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">dojo.provide(&quot;module.that.defines.a.global&quot;);
var someVariable = anAwesomeCalculation();</textarea></div><p>If the code above is evaluated in the global scope, then <code class="docutils literal"><span class="pre">someVariable</span></code> is entered into the global namespace; however,
if it's evaluated in a function scope, then <code class="docutils literal"><span class="pre">someVariable</span></code> is a local variable and disappears when the function
returns.</p>
<p>In version 1.7+, all code that is downloaded as text and evaluated with <code class="docutils literal"><span class="pre">eval</span></code> is evaluated in a function scope. If
you've got code like the above and expect <code class="docutils literal"><span class="pre">someVariable</span></code> be defined in the global space, it will not work in v1.7 (it
only worked sometimes anyway, even if you didn't know it). To define global variables, assign them as properties of
<code class="docutils literal"><span class="pre">dojo.global</span></code>:</p>
<div class="highlight"><pre><span class="nx">dojo</span><span class="p">.</span><span class="nx">provide</span><span class="p">(</span><span class="s2">&quot;module.that.defines.a.global&quot;</span><span class="p">);</span>
<span class="nx">dojo</span><span class="p">.</span><span class="nx">global</span><span class="p">.</span><span class="nx">someVariable</span> <span class="o">=</span> <span class="nx">anAwesomeCalculation</span><span class="p">();</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">dojo.provide(&quot;module.that.defines.a.global&quot;);
dojo.global.someVariable = anAwesomeCalculation();</textarea></div></div>
<div class="section" id="modes-of-operation">
<h2><a class="toc-backref" href="#id22">Modes of Operation</a><a class="headerlink" href="#modes-of-operation" title="Permalink to this headline">¶</a></h2>
<p>The v1.7 loader is able to load both legacy modules and AMD modules in the same application. This allows client
applications written using the legacy API to use dojo, dijit, and other libraries that have already been rewritten with
the AMD API. In such cases, the loader must operate synchronously, since modules written with the legacy API cannot be
loaded asynchronously.</p>
<p>There are two sub-modes to the legacy mode of the v1.7 loader: synchronous and cross-domain.</p>
<div class="section" id="legacy-synchronous-mode">
<h3>Legacy Synchronous Mode<a class="headerlink" href="#legacy-synchronous-mode" title="Permalink to this headline">¶</a></h3>
<p>In this mode, the only difference between the v1.7 loader and previous Dojo loaders is how the loader treats the module
value. Unlike in normal AMD API operation, legacy synchronous mode will cause all dependencies to be immediately
resolved and factory functions executed, even if the related module has not been used yet.</p>
<p>The loader will also assign the return value of an AMD module required by <code class="docutils literal"><span class="pre">dojo.require</span></code> to the object name given in
<code class="docutils literal"><span class="pre">dojo.require</span></code> so long as that object is <code class="docutils literal"><span class="pre">undefined</span></code> at the time <code class="docutils literal"><span class="pre">dojo.require</span></code> is called. This behavior can be
suppressed completely by setting the has feature <code class="docutils literal"><span class="pre">config-publishRequireResult</span></code> to false.</p>
</div>
<div class="section" id="legacy-cross-domain-mode">
<h3>Legacy Cross Domain Mode<a class="headerlink" href="#legacy-cross-domain-mode" title="Permalink to this headline">¶</a></h3>
<p>The moment the loader enters cross-domain mode, even legacy modules start executing asynchronously. This means that if
the loader happens to be in the middle of tracing a dependency tree generated by several interdependent legacy modules,
any future <code class="docutils literal"><span class="pre">dojo.require</span></code> calls will return immediately without first executing the module. v1.6- also exhibited this
behavior.</p>
</div>
</div>
<div class="section" id="configuration-reference">
<h2><a class="toc-backref" href="#id23">Configuration Reference</a><a class="headerlink" href="#configuration-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="configuration-variables">
<h3>Configuration Variables<a class="headerlink" href="#configuration-variables" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>async (true, false/&quot;sync&quot;, &quot;legacyAsync&quot;)</dt>
<dd>If a truthy value other than &quot;sync&quot; or &quot;legacyAsync&quot;, puts the loader in AMD mode. If falsy or &quot;sync&quot;, puts the loader in legacy synchronous mode. &quot;legacyAsync&quot; puts the loader permanently in legacy cross-domain mode. Defaults to false.</dd>
<dt>baseUrl (string)</dt>
<dd>The base URL prepended to a module identifier when converting it to a path or URL. Defaults to the path to dojo.js in browser environments, and the current working directory in non-browser environments.</dd>
<dt>packages (array of package configuration objects)</dt>
<dd>Defined in <a class="reference internal" href="#module-identifiers">Module Identifiers</a>. Default is shown in the <a class="reference internal" href="#default-configuration">Default Configuration</a> section. Note: other properties provided by a package object will be copied (via the JavaScript = operator) to the package configuration variable maintained by the loader at <code class="docutils literal"><span class="pre">require.packs[&lt;name&gt;]</span></code>. Client applications may specify and use such additional properties as required.</dd>
<dt>packagePaths (object)</dt>
<dd>This is a shorthand notation that can be used to specify package configuration for several packages that have the same root location. A particular package's location configuration variable is computed by concatenating the map key at which the particular package configuration object resides and the package name. The package configuration object may be specified as a string, thereby indicating the package name and default values for main and packageMap. For example:</dd>
</dl>
<div class="highlight"><pre><span class="nx">packagePaths</span><span class="o">:</span><span class="p">{</span>
  <span class="s2">&quot;path/to/some/place&quot;</span><span class="o">:</span><span class="p">[</span>
    <span class="s2">&quot;myPackage&quot;</span><span class="p">,</span>
    <span class="p">{</span>
      <span class="nx">name</span><span class="o">:</span><span class="s2">&quot;yourPackage&quot;</span><span class="p">,</span>
      <span class="nx">main</span><span class="o">:</span><span class="s2">&quot;base&quot;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">packagePaths:{
  &quot;path/to/some/place&quot;:[
    &quot;myPackage&quot;,
    {
      name:&quot;yourPackage&quot;,
      main:&quot;base&quot;
    }
  ]
}</textarea></div><p>Is equivalent to:</p>
<div class="highlight"><pre><span class="nx">packages</span><span class="o">:</span><span class="p">[{</span>
  <span class="nx">name</span><span class="o">:</span><span class="s2">&quot;myPackage&quot;</span><span class="p">,</span>
  <span class="nx">location</span><span class="o">:</span><span class="s2">&quot;path/to/some/place/myPackage&quot;</span>
<span class="p">},{</span>
  <span class="nx">name</span><span class="o">:</span><span class="s2">&quot;yourPackage&quot;</span><span class="p">,</span>
  <span class="nx">location</span><span class="o">:</span><span class="s2">&quot;path/to/some/place/youPackage&quot;</span>
<span class="p">}]</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">packages:[{
  name:&quot;myPackage&quot;,
  location:&quot;path/to/some/place/myPackage&quot;
},{
  name:&quot;yourPackage&quot;,
  location:&quot;path/to/some/place/youPackage&quot;
}]</textarea></div><dl class="docutils">
<dt>aliases (array of pairs (arrays of 2 elements))</dt>
<dd>Defined in <a class="reference internal" href="#module-identifiers">Module Identifiers</a>. The first element may either be a regular expression, indicating a set of module identifiers to alias, or a string, indicating a single module identifier to alias. The second element in the pair is always a string, giving the target, absolute module identifier.</dd>
<dt>hasCache: (map:has feature name --&gt; (any, typically boolean or function) has feature test or value)</dt>
<dd>Provides a set of has feature values. Default is shown in the <a class="reference internal" href="#default-configuration">Default Configuration</a> section.</dd>
<dt>waitSeconds (number)</dt>
<dd>Indicates the number of seconds the loader will wait for all requested modules to arrive before signaling a timeout error. The timer is restarted after any module is requested. Defaults to 0 (wait forever).</dd>
<dt>cacheBust (boolean)</dt>
<dd>Applicable to the browser environment only. If truthy, this value is appended to each module URL as a query string parameter to break browser caching. Defaults to false.</dd>
<dt>deps (array of module identifier strings) / callback (function)</dt>
<dd>These configuration variables are only applicable before the loader has been loaded. When provided, they cause the loader to execute <code class="docutils literal"><span class="pre">require(deps,</span> <span class="pre">callback)</span></code> once it has finished loading.</dd>
<dt>stripStrict (boolean)</dt>
<dd>This flag will strip the &quot;use strict&quot; strict directive out of modules. This can be enabled if you need to access the call stack through arguments.callee.caller, but generally it should be disabled (it is disabled by default). This feature only works in sync mode.</dd>
</dl>
</div>
<div class="section" id="default-configuration">
<h3>Default Configuration<a class="headerlink" href="#default-configuration" title="Permalink to this headline">¶</a></h3>
<p>At the time this document was written, this was the default configuration for the Dojo loader. Please consult <code class="docutils literal"><span class="pre">dojo.js</span></code> for the latest and greatest.</p>
<div class="highlight"><pre><span class="p">{</span>
    <span class="c1">// the default configuration for a browser; this will be modified by other environments</span>
    <span class="nx">hasCache</span><span class="o">:</span><span class="p">{</span>
        <span class="s2">&quot;host-browser&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dom&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-amd-factory-scan&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-loader&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-has-api&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-inject-api&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-timeout-api&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-trace-api&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-log-api&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-dom-ready-api&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-publish-privates&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-config-api&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-sniff&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-sync-loader&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;dojo-test-sniff&quot;</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;config-tlmSiblingOfDojo&quot;</span><span class="o">:</span><span class="mi">1</span>
    <span class="p">},</span>
    <span class="nx">packages</span><span class="o">:</span><span class="p">[{</span>
        <span class="c1">// note: like v1.6-, this bootstrap computes baseUrl to be the dojo directory</span>
        <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;dojo&#39;</span><span class="p">,</span>
        <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;.&#39;</span>
    <span class="p">},{</span>
        <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;tests&#39;</span><span class="p">,</span>
        <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;./tests&#39;</span>
    <span class="p">},{</span>
        <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;dijit&#39;</span><span class="p">,</span>
        <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;../dijit&#39;</span>
    <span class="p">},{</span>
        <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;build&#39;</span><span class="p">,</span>
        <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;../util/build&#39;</span>
    <span class="p">},{</span>
        <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;doh&#39;</span><span class="p">,</span>
        <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;../util/doh&#39;</span>
    <span class="p">},{</span>
        <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;dojox&#39;</span><span class="p">,</span>
        <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;../dojox&#39;</span>
    <span class="p">},{</span>
        <span class="nx">name</span><span class="o">:</span><span class="s1">&#39;demos&#39;</span><span class="p">,</span>
        <span class="nx">location</span><span class="o">:</span><span class="s1">&#39;../demos&#39;</span>
    <span class="p">}],</span>
    <span class="nx">trace</span><span class="o">:</span><span class="p">{</span>
        <span class="c1">// these are listed so it&#39;s simple to turn them on/off while debugging loading</span>
        <span class="s2">&quot;loader-inject&quot;</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;loader-define&quot;</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;loader-exec-module&quot;</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;loader-run-factory&quot;</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;loader-finish-exec&quot;</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;loader-define-module&quot;</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;loader-circular-dependency&quot;</span><span class="o">:</span><span class="mi">0</span>
    <span class="p">},</span>
    <span class="nx">async</span><span class="o">:</span><span class="mi">0</span>
<span class="p">}</span>
</pre></div>
<div class="CodeGlassMiniRaw" label="" lang="javascript"><textarea style="display:none">{
    // the default configuration for a browser; this will be modified by other environments
    hasCache:{
        &quot;host-browser&quot;:1,
        &quot;dom&quot;:1,
        &quot;dojo-amd-factory-scan&quot;:1,
        &quot;dojo-loader&quot;:1,
        &quot;dojo-has-api&quot;:1,
        &quot;dojo-inject-api&quot;:1,
        &quot;dojo-timeout-api&quot;:1,
        &quot;dojo-trace-api&quot;:1,
        &quot;dojo-log-api&quot;:1,
        &quot;dojo-dom-ready-api&quot;:1,
        &quot;dojo-publish-privates&quot;:1,
        &quot;dojo-config-api&quot;:1,
        &quot;dojo-sniff&quot;:1,
        &quot;dojo-sync-loader&quot;:1,
        &quot;dojo-test-sniff&quot;:1,
        &quot;config-tlmSiblingOfDojo&quot;:1
    },
    packages:[{
        // note: like v1.6-, this bootstrap computes baseUrl to be the dojo directory
        name:'dojo',
        location:'.'
    },{
        name:'tests',
        location:'./tests'
    },{
        name:'dijit',
        location:'../dijit'
    },{
        name:'build',
        location:'../util/build'
    },{
        name:'doh',
        location:'../util/doh'
    },{
        name:'dojox',
        location:'../dojox'
    },{
        name:'demos',
        location:'../demos'
    }],
    trace:{
        // these are listed so it's simple to turn them on/off while debugging loading
        &quot;loader-inject&quot;:0,
        &quot;loader-define&quot;:0,
        &quot;loader-exec-module&quot;:0,
        &quot;loader-run-factory&quot;:0,
        &quot;loader-finish-exec&quot;:0,
        &quot;loader-define-module&quot;:0,
        &quot;loader-circular-dependency&quot;:0
    },
    async:0
}</textarea></div></div>
</div>
</div>


      </div>
    </div>
      <div class="clearer"></div>
    </div>

  <div class="row">
    <div class="medium-9 columns offset-3">
        <a href="https://docs.google.com/spreadsheet/viewform?hl=en_US&formkey=dFlDcHEyaHMwbEd4MFBObkNrX0E1MFE6MQ&entry_0=http%3A%2F%2Fdojotoolkit.org%2Freference-guide%2F1.10%2F">Error in the documentation? Can’t find what you are looking for? Let us know!</a>
        <div class="footer">
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-22088032-1', 'auto');
		ga('send', 'pageview');

	</script>
</div>
    </div>
  </div>
  
  </body>
</html>